# Ora Language Grammar (BNF/EBNF)
# Version: 0.2.0
# Description: BNF form aligned with GRAMMAR.ebnf

program ::= top_level_declaration*

top_level_declaration ::= contract_declaration
                        | function_declaration
                        | variable_declaration
                        | struct_declaration
                        | enum_declaration
                        | log_declaration
                        | import_declaration
                        | error_declaration
                        | ghost_declaration

import_declaration ::= "@" "import" "(" string_literal ")" ";"
                     | "const" identifier "=" "@" "import" "(" string_literal ")" ";"

contract_declaration ::= "contract" identifier "{" contract_member* "}"

contract_member ::= variable_declaration
                  | function_declaration
                  | log_declaration
                  | struct_declaration
                  | enum_declaration
                  | error_declaration
                  | ghost_declaration
                  | contract_invariant

function_declaration ::= visibility? "fn" function_name "(" parameter_list? ")" return_type?
                         requires_clause* ensures_clause* block

function_name ::= identifier | "init"

visibility ::= "pub"

parameter_list ::= parameter ("," parameter)*

parameter ::= identifier ":" type

return_type ::= "->" type

requires_clause ::= "requires" "(" expression ")"

ensures_clause ::= "ensures" "(" expression ")"

variable_declaration ::= memory_region? variable_kind identifier (":" type)? ("=" expression)? ";"

memory_region ::= "storage" | "memory" | "tstore"

variable_kind ::= "var" | "let" | "const" | "immutable"

struct_declaration ::= "struct" identifier "{" struct_member* "}"

struct_member ::= identifier ":" type ";"

enum_declaration ::= "enum" identifier (":" type)? "{" enum_member_list? "}"

enum_member_list ::= enum_member ("," enum_member)* ","?

enum_member ::= identifier ("=" expression)?

log_declaration ::= "log" identifier "(" log_parameter_list? ")" ";"

log_parameter_list ::= log_parameter ("," log_parameter)*

log_parameter ::= indexed_modifier? identifier ":" type

indexed_modifier ::= "indexed"

error_declaration ::= "error" identifier ("(" parameter_list? ")")? ";"

ghost_declaration ::= "ghost" (variable_declaration | function_declaration | block)

contract_invariant ::= "invariant" identifier "(" expression ")" ";"

type ::= error_union_type | plain_type

plain_type ::= primitive_type
             | map_type
             | array_type
             | slice_type
             | anonymous_struct_type
             | identifier

error_union_type ::= "!" plain_type ("|" plain_type)*

primitive_type ::= "u8" | "u16" | "u32" | "u64" | "u128" | "u256"
                 | "i8" | "i16" | "i32" | "i64" | "i128" | "i256"
                 | "bool" | "address" | "string" | "bytes" | "void"

map_type ::= "map" "<" type "," type ">"

array_type ::= "[" type ";" integer_literal "]"

slice_type ::= "slice" "[" type "]"

anonymous_struct_type ::= "struct" "{" anonymous_struct_field_list "}"

anonymous_struct_field_list ::= anonymous_struct_field ("," anonymous_struct_field)*

anonymous_struct_field ::= identifier ":" type

statement ::= variable_declaration
            | assignment_statement
            | compound_assignment_statement
            | destructuring_assignment
            | expression_statement
            | if_statement
            | while_statement
            | for_statement
            | switch_statement
            | return_statement
            | break_statement
            | continue_statement
            | log_statement
            | lock_statement
            | unlock_statement
            | try_statement
            | assert_statement
            | labeled_block
            | block

assignment_statement ::= lvalue "=" expression ";"

compound_assignment_statement ::= lvalue compound_operator expression ";"

compound_operator ::= "+=" | "-=" | "*=" | "/=" | "%="

destructuring_assignment ::= "let" destructuring_pattern "=" expression ";"

destructuring_pattern ::= "." "{" destructuring_field_list "}"

destructuring_field_list ::= destructuring_field ("," destructuring_field)*

destructuring_field ::= identifier | (identifier ":" identifier)

expression_statement ::= expression ";"

if_statement ::= "if" "(" expression ")" statement ("else" statement)?

while_statement ::= "while" "(" expression ")" invariant_clause* statement

for_statement ::= "for" "(" expression ")" "|" for_pattern "|" invariant_clause* statement

for_pattern ::= identifier ("," identifier)? | destructuring_pattern

invariant_clause ::= "invariant" "(" expression ")"

return_statement ::= "return" expression? ";"

break_statement ::= "break" (":" identifier expression?)? ";"

continue_statement ::= "continue" (":" identifier)? ";"

log_statement ::= "log" identifier "(" expression_list? ")" ";"

lock_statement ::= "@" "lock" "(" expression ")" ";"

unlock_statement ::= "@" "unlock" "(" expression ")" ";"

assert_statement ::= "assert" "(" expression ("," string_literal)? ")" ";"

try_statement ::= "try" block ("catch" ("(" identifier ")")? block)?

try_expression ::= "try" expression

block ::= "{" statement* "}"

labeled_block ::= identifier ":" block

switch_statement ::= "switch" "(" expression ")" "{" switch_arm* "}"

switch_expression ::= "switch" "(" expression ")" "{" switch_expr_arm* "}"

switch_arm ::= switch_pattern "=>" switch_body ","?

switch_expr_arm ::= switch_pattern "=>" expression ","?

switch_pattern ::= expression | range_pattern | "else"

range_pattern ::= expression "..." expression

switch_body ::= expression ";" | block

expression ::= assignment_expression

assignment_expression ::= logical_or_expression (assignment_operator logical_or_expression)?

assignment_operator ::= "=" | "+=" | "-=" | "*=" | "/=" | "%="

logical_or_expression ::= logical_and_expression ("||" logical_and_expression)*

logical_and_expression ::= bitwise_or_expression ("&&" bitwise_or_expression)*

bitwise_or_expression ::= bitwise_xor_expression ("|" bitwise_xor_expression)*

bitwise_xor_expression ::= bitwise_and_expression ("^" bitwise_and_expression)*

bitwise_and_expression ::= equality_expression ("&" equality_expression)*

equality_expression ::= relational_expression (("==" | "!=") relational_expression)*

relational_expression ::= shift_expression (("<" | "<=" | ">" | ">=") shift_expression)*

shift_expression ::= additive_expression (("<<" | ">>") additive_expression)*

additive_expression ::= multiplicative_expression (("+" | "-") multiplicative_expression)*

multiplicative_expression ::= unary_expression (("*" | "/" | "%") unary_expression)*

unary_expression ::= ("!" | "-" | "+")* postfix_expression

postfix_expression ::= primary_expression postfix_operator*

postfix_operator ::= "." identifier | "[" expression "]" | "(" expression_list? ")"

lvalue ::= lvalue_atom lvalue_suffix*

lvalue_atom ::= identifier | "(" lvalue ")"

lvalue_suffix ::= "." identifier | "[" expression "]"

primary_expression ::= literal
                     | identifier
                     | "(" expression ")"
                     | try_expression
                     | old_expression
                     | comptime_expression
                     | cast_expression
                     | error_expression
                     | quantified_expression
                     | anonymous_struct_literal
                     | switch_expression
                     | array_literal

array_literal ::= "[" expression_list? "]"

old_expression ::= "old" "(" expression ")"

comptime_expression ::= "comptime" block

cast_expression ::= "@" "cast" "(" type "," expression ")"

error_expression ::= "error" "." identifier ("(" expression_list? ")")?

quantified_expression ::= quantifier identifier ":" type ("where" expression)? "=>" expression

quantifier ::= "forall" | "exists"

anonymous_struct_literal ::= "." "{" anonymous_struct_literal_field_list? "}"

anonymous_struct_literal_field_list ::= anonymous_struct_literal_field ("," anonymous_struct_literal_field)* ","?

anonymous_struct_literal_field ::= "." identifier "=" expression

expression_list ::= expression ("," expression)*

literal ::= integer_literal | string_literal | boolean_literal | address_literal | hex_literal

integer_literal ::= digit (digit | "_")*

string_literal ::= '"' ("\\" ('"' | "\\") | (character - '"' - "\\"))* '"'

boolean_literal ::= "true" | "false"

address_literal ::= "0x" hex_digit+

hex_literal ::= "0x" hex_digit+

identifier ::= (letter | "_") (letter | digit | "_")*

letter ::= ? alphabetic character ?

digit ::= ? '0' .. '9' ?

hex_digit ::= ? digit | 'a'..'f' | 'A'..'F' ?

character ::= ? any valid Unicode character ?
