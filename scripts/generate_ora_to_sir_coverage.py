#!/usr/bin/env python3
"""
Generate docs/compiler/ora_to_sir_coverage.md from OraOps.td, SIROps.td,
and OraToSIR conversion registration.
"""

from __future__ import annotations

import re
from pathlib import Path


ROOT = Path(__file__).resolve().parents[1]
ORA_OPS = ROOT / "src/mlir/ora/td/OraOps.td"
SIR_OPS = ROOT / "src/mlir/IR/td/SIROps.td"
ORA_TO_SIR = ROOT / "src/mlir/ora/lowering/OraToSIR/OraToSIR.cpp"
OUTPUT = ROOT / "docs/compiler/ora_to_sir_coverage.md"


def parse_ops(path: Path, dialect_prefix: str) -> list[dict]:
    text = path.read_text()
    ops = []
    pattern = re.compile(
        r"^\s*def\s+(\w+)\s*:\s*"
        + re.escape(dialect_prefix)
        + r"\w*Op<\"([^\"]+)\">",
        re.MULTILINE,
    )
    for def_name, mnemonic in pattern.findall(text):
        ops.append(
            {
                "def_name": def_name,
                "mnemonic": mnemonic,
                "full_name": f"{dialect_prefix.split('_')[0].lower()}.{mnemonic}",
            }
        )
    return ops


def parse_patterns(path: Path) -> list[str]:
    text = path.read_text()
    patterns = []
    for match in re.findall(r"patterns\.add<([^>]+)>", text):
        for name in match.split(","):
            name = name.strip()
            if name:
                patterns.append(name)
    return sorted(set(patterns))


def parse_illegal_ops(path: Path) -> set[str]:
    text = path.read_text()
    illegal = set()
    for match in re.findall(r"addIllegalOp<([^>]+)>", text):
        for name in match.split(","):
            name = name.strip()
            if name.startswith("ora::"):
                illegal.add(name.replace("ora::", ""))
    return illegal


def parse_dynamic_legal_ops(path: Path) -> set[str]:
    text = path.read_text()
    legal = set()
    for match in re.findall(r"addDynamicallyLegalOp<([^>]+)>", text):
        for name in match.split(","):
            name = name.strip()
            if name.startswith("ora::"):
                legal.add(name.replace("ora::", ""))
    return legal


def build_rows(
    ora_ops: list[dict],
    patterns: list[str],
    illegal_ops: set[str],
    dynamic_legal_ops: set[str],
) -> list[dict]:
    base_to_mnemonic = {}
    base_to_def = {}
    for op in ora_ops:
        base = op["def_name"].removeprefix("Ora_")
        base_to_mnemonic[base] = op["mnemonic"]
        base_to_def[base] = op["def_name"]

    op_pattern = {}
    for pattern in patterns:
        if pattern.startswith("Convert") and pattern.endswith("Op"):
            base = pattern[len("Convert") :]
            if base in base_to_mnemonic:
                op_pattern[base] = pattern

    rows = []
    for op in sorted(ora_ops, key=lambda x: x["mnemonic"]):
        base = op["def_name"].removeprefix("Ora_")
        pattern = op_pattern.get(base)
        status = "⚠️ partial" if pattern else "❌ missing"
        lowering = f"pattern: {pattern}" if pattern else "tbd"
        notes = []
        if base in illegal_ops:
            notes.append("target illegal")
        if base in dynamic_legal_ops:
            notes.append("dynamic legal")
        rows.append(
            {
                "op": f"ora.{op['mnemonic']}",
                "category": "tbd",
                "status": status,
                "lowering": lowering,
                "notes": ", ".join(notes) if notes else "",
            }
        )
    return rows


def render_markdown(
    rows: list[dict], sir_ops: list[dict], patterns: list[str], illegal_ops: set[str]
) -> str:
    lines = []
    lines.append("# Ora to SIR coverage")
    lines.append("")
    lines.append("Generated by `scripts/generate_ora_to_sir_coverage.py`.")
    lines.append("")
    lines.append("Acceptance criteria")
    lines.append("- Inventory of Ora ops and current SIR coverage (documented).")
    lines.append("- Dialect verification rules reviewed and aligned with lowering (OraDialect/SIRDialect).")
    lines.append("- Lowering patterns added for missing operations (logs, errors, try/catch, structs/enums, strings/bytes, maps, events).")
    lines.append("- Type conversion updated to handle all Ora types used by these ops.")
    lines.append("- Target legality and verification updated to prevent silent fallback.")
    lines.append("- Tests for at least one end-to-end contract exercising new SIR coverage.")
    lines.append("")
    lines.append("## Coverage table")
    lines.append("")
    lines.append("| Ora op | Category | Status | Lowering | Notes |")
    lines.append("| --- | --- | --- | --- | --- |")
    for row in rows:
        lines.append(
            f"| {row['op']} | {row['category']} | {row['status']} | {row['lowering']} | {row['notes']} |"
        )
    lines.append("")
    lines.append("## SIR op inventory")
    lines.append("")
    for op in sorted(sir_ops, key=lambda x: x["mnemonic"]):
        lines.append(f"- sir.{op['mnemonic']}")
    lines.append("")
    lines.append("## Ora -> SIR patterns (registered)")
    lines.append("")
    for pattern in patterns:
        lines.append(f"- {pattern}")
    lines.append("")
    lines.append("## Conversion target notes")
    lines.append("")
    if illegal_ops:
        lines.append("- Ora ops explicitly illegal in target:")
        for name in sorted(illegal_ops):
            lines.append(f"  - {name}")
    else:
        lines.append("- Ora ops explicitly illegal in target: none")
    lines.append("")
    return "\n".join(lines)


def main() -> None:
    ora_ops = parse_ops(ORA_OPS, "Ora_")
    sir_ops = parse_ops(SIR_OPS, "SIR_")
    patterns = parse_patterns(ORA_TO_SIR)
    illegal_ops = parse_illegal_ops(ORA_TO_SIR)
    dynamic_legal_ops = parse_dynamic_legal_ops(ORA_TO_SIR)
    rows = build_rows(ora_ops, patterns, illegal_ops, dynamic_legal_ops)
    content = render_markdown(rows, sir_ops, patterns, illegal_ops)
    OUTPUT.write_text(content)


if __name__ == "__main__":
    main()
