---
slug: welcome-to-ora
title: Welcome to Ora
authors: [axe]
tags: [announcement]
---

Hey! I'm building Ora, a smart contract language for EVM with particular features that make everything less magical

<!-- truncate -->

## Why Ora?

Solidity is... fine. But I wanted something that actually makes sense. No weird implicit conversions, no silent failures, and way more compiler guarantees.

**The core idea: comptime > runtime**

If something can be checked at compile time, it should be. Why waste gas on bugs the compiler could catch?

Ora gives you:
- **Always-known memory model**: `storage`, `memory`, `tstore` - you always know which one you're using, the compiler tracks it
- **Formal verification as a compiler step**: `requires`/`ensures` aren't bolted on - they're part of compilation, proving your contracts work before deployment
- **Powerful without shortcuts**: Expressive constructs (like switch in all its variations) that don't sacrifice security for convenience
- **Explicit error handling**: `!T | E1 | E2` - no mystery reverts

The compiler does the heavy lifting. Your contracts do less guessing.

## Where we're at

The compiler is early alpha. 79% of examples compile (23 out of 29). 

What works:
- Lexer, parser, type checker
- Basic code generation through MLIR to Yul
- Structs, enums, error unions
- All the memory regions
- Switch expressions (proper ones, not Solidity's weird fallthrough)

What's missing:
- Some loop syntax
- Standard library
- All the nice-to-haves

## Why blog?

I'll post updates here when I hit milestones or figure out something interesting. No marketing BS, just what's actually happening with the compiler.

If you want to help build this thing, the repo is open. Or just watch - seeing what breaks and what works is useful too.

---

*axe*

