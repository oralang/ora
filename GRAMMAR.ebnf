# Ora Language Grammar (EBNF)
# Version: 0.2.0 (Revised)
# Description: EBNF form aligned with GRAMMAR.bnf

# ==========================================
# PROGRAM STRUCTURE
# ==========================================

Program = { TopLevelDeclaration } ;

TopLevelDeclaration =
    ContractDeclaration
  | FunctionDeclaration
  | VariableDeclaration
  | StructDeclaration
  | EnumDeclaration
  | LogDeclaration
  | ImportDeclaration
  | ErrorDeclaration ;

# ==========================================
# IMPORT DECLARATIONS
# ==========================================

ImportDeclaration =
    "@" "import" "(" StringLiteral ")" ";"
  | "const" Identifier "=" "@" "import" "(" StringLiteral ")" ";" ;

# ==========================================
# CONTRACT DECLARATIONS
# ==========================================

ContractDeclaration = "contract" Identifier "{" { ContractMember } "}" ;

ContractMember =
    VariableDeclaration
  | FunctionDeclaration
  | LogDeclaration
  | StructDeclaration
  | EnumDeclaration
  | ErrorDeclaration ;

# ==========================================
# FUNCTION DECLARATIONS
# ==========================================

FunctionDeclaration = [ "inline" ] [ "pub" ]
  "fn" FunctionName "(" [ ParameterList ] ")" [ ReturnType ]
  { RequiresClause } { EnsuresClause } Block ;

FunctionName = Identifier | "init" ;

ParameterList = Parameter { "," Parameter } ;

Parameter = Identifier ":" Type ;

ReturnType = "->" Type ;

RequiresClause = "requires" "(" Expression ")" ;
EnsuresClause  = "ensures"  "(" Expression ")" ;

# ==========================================
# VARIABLE DECLARATIONS
# ==========================================

VariableDeclaration = [ MemoryRegion ] VariableKind Identifier
  [ ":" Type ] [ "=" Expression ] ";" ;

MemoryRegion = "storage" | "memory" | "tstore" ;

VariableKind = "var" | "let" | "const" | "immutable" ;

# ==========================================
# STRUCT DECLARATIONS
# ==========================================

StructDeclaration = "struct" Identifier "{" { StructMember } "}" ;

StructMember = Identifier ":" Type ";" ;

# ==========================================
# ENUM DECLARATIONS
# ==========================================

EnumDeclaration = "enum" Identifier [ ":" Type ] "{" [ EnumMemberList ] "}" ;

EnumMemberList = EnumMember { "," EnumMember } [ "," ] ;

EnumMember = Identifier [ "=" Expression ] ;

# ==========================================
# LOG DECLARATIONS (EVENTS)
# ==========================================

LogDeclaration = "log" Identifier "(" [ LogParameterList ] ")" ";" ;

LogParameterList = LogParameter { "," LogParameter } ;

LogParameter = [ "indexed" ] Identifier ":" Type ;

# ==========================================
# ERROR DECLARATIONS
# ==========================================

ErrorDeclaration = "error" Identifier [ "(" [ ParameterList ] ")" ] ";" ;

# ==========================================
# TYPE SYSTEM
# ==========================================

Type =
    ErrorPrefixType
  | ErrorUnionType
  | PrimitiveType
  | MapType
  | DoublemapType
  | ArrayType
  | SliceType
  | AnonymousStructType
  | Identifier ;

ErrorPrefixType = "!" Type ;

# Note: Error unions are expressed explicitly as !T | E1 | E2 ...
ErrorUnionType = "!" Type { "|" Type } ;

PrimitiveType =
    "u8" | "u16" | "u32" | "u64" | "u128" | "u256"
  | "i8" | "i16" | "i32" | "i64" | "i128" | "i256"
  | "bool" | "address" | "string" | "bytes" | "void" ;

MapType       = "map"       "[" Type "," Type "]" ;
DoublemapType = "doublemap" "[" Type "," Type "," Type "]" ;

# Arrays and slices
ArrayType = "[" Type ";" IntegerLiteral "]" ;           # [T; N]
SliceType = "slice" "[" Type "]" ;                      # slice[T]

AnonymousStructType = "struct" "{" AnonymousStructFieldList "}" ;
AnonymousStructFieldList = AnonymousStructField { "," AnonymousStructField } ;
AnonymousStructField = Identifier ":" Type ;

# ==========================================
# STATEMENTS
# ==========================================

Statement =
    VariableDeclaration
  | AssignmentStatement
  | CompoundAssignmentStatement
  | DestructuringAssignment
  | MoveStatement
  | ExpressionStatement
  | IfStatement
  | WhileStatement
  | ForStatement
  | SwitchStatement
  | ReturnStatement
  | BreakStatement
  | ContinueStatement
  | LogStatement
  | LockStatement
  | UnlockStatement
  | TryStatement
  | Block ;

AssignmentStatement         = LValue "="  Expression ";" ;
CompoundAssignmentStatement = LValue CompoundOperator Expression ";" ;
CompoundOperator            = "+=" | "-=" | "*=" | "/=" | "%=" ;

DestructuringAssignment = "let" DestructuringPattern "=" Expression ";" ;
DestructuringPattern    = "." "{" DestructuringFieldList "}" ;
DestructuringFieldList  = DestructuringField { "," DestructuringField } ;
DestructuringField      = Identifier | ( Identifier ":" Identifier ) ;

MoveStatement        = "move" Expression "from" Expression "to" Expression ";" ;
ExpressionStatement  = Expression ";" ;

IfStatement    = "if"    "(" Expression ")" Statement [ "else" Statement ] ;
WhileStatement = "while" "(" Expression ")" Statement ;

# foreach-style loop: for (iterable) |item[, index]| statement
ForStatement = "for" "(" Expression ")" "|" Identifier [ "," Identifier ] "|" Statement ;

ReturnStatement   = "return" [ Expression ] ";" ;
BreakStatement    = "break"  [ ":" Identifier [ Expression ] ] ";" ;
ContinueStatement = "continue" [ ":" Identifier ] ";" ;

LogStatement    = "log" Identifier "(" [ ExpressionList ] ")" ";" ;
LockStatement   = "@" "lock"   "(" Expression ")" ";" ;
UnlockStatement = "@" "unlock" "(" Expression ")" ";" ;

TryStatement = "try" Expression [ "catch" [ "|" Identifier "|" ] Block ] ;

Block        = "{" { Statement } "}" ;
LabeledBlock = Identifier ":" Block ;

# ==========================================
# SWITCH STATEMENTS AND EXPRESSIONS
# ==========================================

SwitchStatement   = "switch" "(" Expression ")" "{" { SwitchArm } "}" ;
SwitchExpression  = "switch" "(" Expression ")" "{" { SwitchExprArm } "}" ;

SwitchArm    = SwitchPattern "=>" SwitchBody [ "," ] ;
SwitchExprArm = SwitchPattern "=>" Expression [ "," ] ;

# Patterns
SwitchPattern = Expression | RangePattern | "else" ;
RangePattern  = Expression "..." Expression ;

SwitchBody = ( Expression ";" ) | Block ;

# ==========================================
# EXPRESSIONS (precedence)
# ==========================================

Expression = AssignmentExpression ;

AssignmentExpression = LogicalOrExpression [ AssignmentOperator LogicalOrExpression ] ;
AssignmentOperator   = "=" | "+=" | "-=" | "*=" | "/=" | "%=" ;

LogicalOrExpression  = LogicalAndExpression { "||" LogicalAndExpression } ;
LogicalAndExpression = BitwiseOrExpression  { "&&" BitwiseOrExpression } ;
BitwiseOrExpression  = BitwiseXorExpression { "|"  BitwiseXorExpression } ;
BitwiseXorExpression = BitwiseAndExpression { "^"  BitwiseAndExpression } ;
BitwiseAndExpression = EqualityExpression   { "&"  EqualityExpression } ;

EqualityExpression   = RelationalExpression { ( "==" | "!=" ) RelationalExpression } ;
RelationalExpression = ShiftExpression      { ( "<" | "<=" | ">" | ">=" ) ShiftExpression } ;
ShiftExpression      = AdditiveExpression   { ( "<<" | ">>" ) AdditiveExpression } ;
AdditiveExpression   = MultiplicativeExpression { ( "+" | "-" ) MultiplicativeExpression } ;
MultiplicativeExpression = UnaryExpression { ( "*" | "/" | "%" ) UnaryExpression } ;

UnaryExpression   = { ( "!" | "-" | "+" ) } PostfixExpression ;
PostfixExpression = PrimaryExpression { PostfixOperator } ;

# Valid assignment target
LValue = PostfixExpression ;

PostfixOperator =
    "." Identifier
  | "[" Expression "]"
  | "(" [ ExpressionList ] ")" ;  (* Function call *)

PrimaryExpression =
    Literal
  | Identifier
  | "(" Expression ")"
  | OldExpression
  | ComptimeExpression
  | CastExpression
  | ErrorExpression
  | QuantifiedExpression
  | AnonymousStructLiteral
  | SwitchExpression
  | ArrayLiteral ;

ArrayLiteral = "[" [ ExpressionList ] "]" ;

OldExpression      = "old" "(" Expression ")" ;
ComptimeExpression = "comptime" Block ;
CastExpression     = "@" "cast" "(" Type "," Expression ")" ;
ErrorExpression    = "error" "." Identifier ;

AnonymousStructLiteral = "." "{" [ AnonymousStructLiteralFieldList ] "}" ;
AnonymousStructLiteralFieldList = AnonymousStructLiteralField { "," AnonymousStructLiteralField } [ "," ] ;
AnonymousStructLiteralField = "." Identifier "=" Expression ;

ExpressionList = Expression { "," Expression } ;

# ==========================================
# LITERALS
# ==========================================

Literal = IntegerLiteral | StringLiteral | BooleanLiteral | AddressLiteral | HexLiteral ;

IntegerLiteral = Digit { Digit | "_" } ;
StringLiteral  = '"' { '\\' ( '"' | '\\' ) | ( Character - '"' - '\\' ) } '"' ;
BooleanLiteral = "true" | "false" ;
AddressLiteral = "0x" HexDigit { HexDigit } ;
HexLiteral     = "0x" HexDigit { HexDigit } ;

# ==========================================
# LEXICAL ELEMENTS
# ==========================================

Identifier = ( Letter | "_" ) { Letter | Digit | "_" } ;

Letter   = ? any alphabetic character ? ;
Digit    = ? '0' .. '9' ? ;
HexDigit = ? Digit | 'a'..'f' | 'A'..'F' ? ;
Character = ? any valid Unicode character ? ;