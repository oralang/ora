//! Yul Compiler Bindings
//!
//! This module provides Zig bindings for the Solidity Yul compiler through FFI.
//! It wraps the C++ Yul compiler functionality in a safe Zig interface with
//! proper memory management and error handling.

const std = @import("std");
const print = std.debug.print;

/// C bindings for Yul wrapper
const c = @cImport({
    @cInclude("yul_wrapper.h");
});

/// Zig wrapper for YulCompileResult
///
/// Represents the result of a Yul compilation operation, containing
/// either successful bytecode or error information.
pub const YulCompileResult = struct {
    /// Whether compilation was successful
    success: bool,
    /// Generated bytecode (hex string) if successful
    bytecode: ?[]const u8,
    /// Error message if compilation failed
    error_message: ?[]const u8,

    const Self = @This();

    /// Cleanup allocated memory for result
    ///
    /// Args:
    ///     allocator: Allocator used for bytecode/error message
    pub fn deinit(self: *Self, allocator: std.mem.Allocator) void {
        if (self.bytecode) |bytecode| {
            allocator.free(bytecode);
        }
        if (self.error_message) |error_msg| {
            allocator.free(error_msg);
        }
    }
};

/// Zig wrapper for Yul compilation
///
/// Provides a safe interface to the Solidity Yul compiler with
/// proper error handling and memory management.
pub const YulCompiler = struct {
    /// Compile Yul source code to EVM bytecode
    ///
    /// Args:
    ///     allocator: Memory allocator for result data
    ///     yul_source: Yul source code to compile
    ///
    /// Returns:
    ///     Compilation result with bytecode or error information
    ///
    /// Errors:
    ///     CompilationFailed: If the C wrapper returns null
    pub fn compile(allocator: std.mem.Allocator, yul_source: []const u8) !YulCompileResult {
        // Ensure null-terminated string
        const c_source = try allocator.dupeZ(u8, yul_source);
        defer allocator.free(c_source);

        // Call C wrapper
        const c_result = c.yul_compile_to_bytecode(c_source.ptr);
        defer c.yul_free_result(c_result);

        if (c_result == null) {
            return error.CompilationFailed;
        }

        var result = YulCompileResult{
            .success = c_result.*.success != 0,
            .bytecode = null,
            .error_message = null,
        };

        // Copy bytecode if successful
        if (result.success and c_result.*.bytecode != null) {
            const bytecode_len = c_result.*.bytecode_length;
            const bytecode_slice = c_result.*.bytecode[0..bytecode_len];
            result.bytecode = try allocator.dupe(u8, bytecode_slice);
        }

        // Copy error message if present
        if (c_result.*.error_message != null) {
            const error_msg = std.mem.span(c_result.*.error_message);
            result.error_message = try allocator.dupe(u8, error_msg);
        }

        return result;
    }

    /// Get Yul compiler version information
    ///
    /// Returns:
    ///     Version string from the underlying Solidity compiler
    pub fn getVersion() []const u8 {
        const c_version = c.yul_get_version();
        return std.mem.span(c_version);
    }
};

/// Test function for Yul compilation
///
/// Tests the Yul compiler bindings with a simple Yul program
/// that adds two numbers and stores the result.
pub fn test_yul_compilation() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    const simple_yul =
        \\{
        \\    let x := 42
        \\    let y := add(x, 1)
        \\    mstore(0, y)
        \\    return(0, 32)
        \\}
    ;

    print("Yul Compiler Version: {s}\n", .{YulCompiler.getVersion()});
    print("Compiling Yul source:\n{s}\n", .{simple_yul});

    var result = YulCompiler.compile(allocator, simple_yul) catch |err| {
        print("Failed to compile: {s}\n", .{@errorName(err)});
        return;
    };
    defer result.deinit(allocator);

    if (result.success) {
        if (result.bytecode) |bytecode| {
            print("Compilation successful!\n");
            print("Bytecode: {s}\n", .{bytecode});
        } else {
            print("Compilation successful but no bytecode generated\n");
        }
    } else {
        print("Compilation failed\n");
        if (result.error_message) |error_msg| {
            print("Error: {s}\n", .{error_msg});
        }
    }
}
