// ============================================================================
// Guard Showcase: SMT-proven vs Runtime Guards
// ============================================================================
//
// Each refinement has two functions:
// - Proven: has requires clauses that let SMT remove the guard
// - Runtime: missing requires so the guard stays
//
// ============================================================================

contract GuardShowcase {
    // NonZeroAddress
    pub fn provenNonZero(addr: NonZeroAddress)
        requires(addr != std.constants.ZERO_ADDRESS)
    {
        let owner: NonZeroAddress = addr;
    }

    pub fn runtimeNonZero(addr: address) -> bool {
        if (addr == std.constants.ZERO_ADDRESS) {
            return false;
        }
        let owner: NonZeroAddress = addr;
        return true;
    }

    // MinValue
    pub fn provenMin(value: MinValue<u256, 10>)
        requires(value >= 10)
    {
        let v: MinValue<u256, 10> = value;
    }

    pub fn runtimeMin(value: u256) -> bool {
        if (value < 10) {
            return false;
        }
        let v: MinValue<u256, 10> = value;
        return true;
    }

    // MaxValue
    pub fn provenMax(value: MaxValue<u256, 100>)
        requires(value <= 100)
    {
        let v: MaxValue<u256, 100> = value;
    }

    pub fn runtimeMax(value: u256) -> bool {
        if (value > 100) {
            return false;
        }
        let v: MaxValue<u256, 100> = value;
        return true;
    }

    // InRange
    pub fn provenInRange(value: InRange<u256, 0, 100>)
        requires(value >= 10)
        requires(value <= 100)
    {
        let v: InRange<u256, 0, 100> = value;
    }

    pub fn runtimeInRange(value: u256) -> bool {
        if (value > 100) {
            return false;
        }
        let v: InRange<u256, 0, 100> = value;
        return true;
    }

    // Exact division
    pub fn provenExact(dividend: Exact<u256>, divisor: u256)
        requires(divisor != 0)
        requires(dividend % divisor == 0)
    {
        let q: u256 = dividend / divisor;
    }

    pub fn runtimeExact(dividend: u256, divisor: u256) -> bool {
        if (divisor == 0) {
            return false;
        }
        if (dividend % divisor != 0) {
            return false;
        }
        let exact_dividend: Exact<u256> = dividend;
        let q: u256 = exact_dividend / divisor;
        return true;
    }

    // Scaled (type-level only, no guards expected)
    pub fn scaledAdd(a: Scaled<u256, 18>, b: Scaled<u256, 18>)
        requires(a > 0)
        requires(b > 0)
        requires(a <= std.constants.U256_MAX - b)
    {
        let c: Scaled<u256, 18> = a + b;
    }

    pub fn scaledMul(a: Scaled<u256, 18>, b: Scaled<u256, 6>) -> bool {
        if (a != 0) {
            if (b > std.constants.U256_MAX / a) {
                return false;
            }
        }
        let c: Scaled<u256, 24> = a * b;
        return true;
    }
}
