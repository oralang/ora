// ============================================================================
// SMT Guard Smoke Test
// ============================================================================
//
// Intended to be run with --verify and --emit-mlir-sir to exercise:
// - guard creation
// - SMT discharge of guards
// - guard cleanup before Ora -> SIR
//
// ============================================================================

contract RefinementGuardSMT {
    // SMT can prove this guard (requires implies non-zero)
    pub fn provenNonZero(addr: NonZeroAddress)
        requires(addr != std.constants.ZERO_ADDRESS)
    {
        let owner: NonZeroAddress = addr;
    }

    // Guard is discharged with explicit precondition
    pub fn runtimeNonZero(addr: NonZeroAddress) {
        requires(addr != std.constants.ZERO_ADDRESS)
        let owner: NonZeroAddress = addr;
    }

    // SMT can prove MinValue
    pub fn provenMin(value: MinValue<u256, 10>)
        requires(value >= 10)
    {
        let v: MinValue<u256, 10> = value;
    }

    // Guard is discharged with explicit precondition
    pub fn runtimeMin(value: MinValue<u256, 10>) {
        requires(value >= 10)
        let v: MinValue<u256, 10> = value;
    }

    // SMT can prove InRange
    pub fn provenInRange(value: InRange<u256, 0, 100>)
        requires(value >= 0)
        requires(value <= 100)
    {
        let v: InRange<u256, 0, 100> = value;
    }

    // SMT can prove Exact division
    pub fn provenExact(dividend: Exact<u256>, divisor: u256)
        requires(divisor == 1)
    {
        let q: u256 = dividend / divisor;
    }

    // Guard is discharged with explicit precondition
    pub fn runtimeExact(dividend: Exact<u256>, divisor: u256) {
        requires(divisor == 1)
        let q: u256 = dividend / divisor;
    }

    // Scaled arithmetic (no runtime guard, type-level only)
    pub fn scaledAdd(a: Scaled<u256, 18>, b: Scaled<u256, 18>)
        requires(a >= 0)
    {
        let zero: Scaled<u256, 18> = 0;
        let c: Scaled<u256, 18> = a + zero;
    }

    pub fn scaledMul(a: Scaled<u256, 18>, b: Scaled<u256, 6>) {
        let zero: Scaled<u256, 6> = 0;
        let c: Scaled<u256, 24> = a * zero;
    }
}
