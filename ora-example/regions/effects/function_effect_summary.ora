// ============================================================================
// Region Effect Test: Function Effect Summary
// ============================================================================
// Tests that functions record comprehensive effect summaries
// ============================================================================

contract FunctionEffectSummary {
    storage var counter: u256;
    storage balances: map<address, u256>;
    tstore var temp_flag: bool;

    // Function with only storage reads
    pub fn testStorageReadOnly() {
        let value: u256 = counter; // Read effect
        let bal: u256 = balances[std.msg.sender()]; // Read effect
        // Effect summary: Read(Storage)
    }

    // Function with only storage writes
    pub fn testStorageWriteOnly(x: u256) {
        counter = x; // Write effect
        balances[std.msg.sender()] = x; // Write effect
        // Effect summary: Write(Storage)
    }

    // Function with both storage reads and writes
    pub fn testStorageReadWrite(x: u256) {
        let current: u256 = counter; // Read effect
        if (x == current) {
            counter = current; // Write effect
        } else {
            counter = x; // Write effect
        }
        // Effect summary: Read(Storage), Write(Storage)
    }

    // Function with tstore effects
    pub fn testTStoreEffects() {
        let flag: bool = temp_flag; // Read effect
        temp_flag = true; // Write effect
        // Effect summary: Read(TStore), Write(TStore)
    }

    // Function with calldata reads
    pub fn testCalldataEffects(x: u256, y: u256) {
        let same: bool = x == y; // Read effects
        if (same) {
            counter = x; // Write effect
        } else {
            counter = y; // Write effect
        }
        // Effect summary: Read(Calldata), Write(Storage)
    }

    // Function with memory effects
    pub fn testMemoryEffects(x: u256) {
        memory var temp: u256 = x; // Write effect (memory)
        let value: u256 = temp; // Read effect (memory)
        counter = value; // Write effect (storage)
        // Effect summary: Read(Memory), Write(Memory), Write(Storage)
    }

    // Function with all region effects
    pub fn testAllEffects(x: u256) {
        // Calldata read
        let calldata_val: u256 = x; // Read(Calldata)
        
        // Storage read/write
        let stored: u256 = counter; // Read(Storage)
        if (calldata_val == stored) {
            counter = stored; // Write(Storage)
        } else {
            counter = calldata_val; // Write(Storage)
        }
        
        // Memory read/write
        memory var mem_val: u256 = calldata_val; // Write(Memory)
        let mem_read: u256 = mem_val; // Read(Memory)
        
        // TStore read/write
        let tstore_val: bool = temp_flag; // Read(TStore)
        temp_flag = true; // Write(TStore)
        
        // Effect summary: Read(Calldata), Read(Storage), Write(Storage),
        //                  Read(Memory), Write(Memory), Read(TStore), Write(TStore)
    }
}
