contract ComptimeEdgeCases {
    // ================================================================
    // 1. Transitive pure calls — fn calling fn calling fn
    // ================================================================
    fn add(a: u256, b: u256) -> u256 { return a + b; }
    fn mul(a: u256, b: u256) -> u256 { return a * b; }

    fn sum_of_squares(a: u256, b: u256) -> u256 {
        return add(mul(a, a), mul(b, b));
    }

    pub fn test_transitive() -> u256 {
        // sum_of_squares(3, 4) = 9 + 16 = 25
        const val: u256 = sum_of_squares(3, 4);
        return val;
    }

    // ================================================================
    // 2. Recursive comptime function
    // ================================================================
    fn factorial(n: u256) -> u256 {
        if (n == 0) { return 1; }
        return n * factorial(n - 1);
    }

    pub fn test_recursive() -> u256 {
        // factorial(5) = 120
        const fact5: u256 = factorial(5);
        return fact5;
    }

    // ================================================================
    // 3. Conditional logic inside comptime fn
    // ================================================================
    fn clamp(x: u256, lo: u256, hi: u256) -> u256 {
        if (x < lo) { return lo; }
        if (x > hi) { return hi; }
        return x;
    }

    pub fn test_clamp() -> u256 {
        const a: u256 = clamp(500, 0, 100);   // clamped to 100
        const b: u256 = clamp(50, 0, 100);    // stays 50
        const c: u256 = clamp(0, 10, 100);    // clamped to 10
        return a + b + c;                       // 100 + 50 + 10 = 160
    }

    // ================================================================
    // 4. Comptime fn with loop (while)
    // ================================================================
    fn power(base: u256, exp: u256) -> u256 {
        var acc: u256 = 1;
        var i: u256 = 0;
        while (i < exp) {
            acc = acc * base;
            i = i + 1;
        }
        return acc;
    }

    pub fn test_power() -> u256 {
        // power(2, 10) = 1024
        const val: u256 = power(2, 10);
        return val;
    }

    // ================================================================
    // 5. Impure function — should NOT be folded (uses storage)
    // ================================================================
    storage var counter: u256;

    fn read_counter() -> u256 {
        
        return counter;
    }

    pub fn test_impure(x: u256) -> u256 {
        const val: u256 = x + 1;
        // read_counter() touches Storage — should remain runtime call
        const counter: u256 = read_counter();
        return val + counter;
    }

    // ================================================================
    // 6. Mixed comptime + runtime — partial folding
    // ================================================================
    pub fn test_mixed(runtime_val: u256) -> u256 {
        // square(10) folds to 100, but runtime_val stays runtime
        const ct_part: u256 = mul(10, 10);
        return ct_part + runtime_val;
    }

    // ================================================================
    // 7. Comptime param: only literal args accepted
    // ================================================================
    fn align_up(comptime alignment: u256, value: u256) -> u256 {
        const mask: u256 = alignment - 1;
        return (value + mask) - ((value + mask) % alignment);
    }

    pub fn test_comptime_param_mixed(x: u256) -> u256 {
        // alignment is comptime (32), x is runtime
        return align_up(32, x);
    }

    // ================================================================
    // 8. Deeply nested comptime calls
    // ================================================================
    fn inc(x: u256) -> u256 { return x + 1; }

    pub fn test_deep_nesting() -> u256 {
        // inc(inc(inc(inc(inc(0))))) = 5
        const val: u256 = inc(inc(inc(inc(inc(0)))));
        return val;
    }

    // ================================================================
    // 9. Comptime fn returning bool
    // ================================================================
    fn is_power_of_two(x: u256) -> bool {
        if (x == 0) { return false; }
        return (x % 2) == 0;
    }

    pub fn test_bool_comptime() -> u256 {
        const check: bool = is_power_of_two(256);
        if (check) { return 1; }
        return 0;
    }
}
