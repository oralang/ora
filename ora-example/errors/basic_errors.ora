// ==========================================
// ERROR HANDLING TEST
// ==========================================
// This file tests error declarations and error handling

// Top-level error declarations
error InsufficientBalance(required: u256, available: u256);
error InvalidAddress;
error Unauthorized(caller: address, required: address);
error InvalidAmount(amount: u256);
error ZeroValueNotAllowed;
error ValueTooLarge;

contract ErrorHandlingTest {
    storage var owner: address;
    storage var balance: u256;
    
    pub fn init() {
        owner = std.transaction.sender;
        balance = 1000;
    }
    
    // Function that can return errors
    pub fn transfer(recipient: address, amount: u256) -> !bool | InsufficientBalance | InvalidAddress
        requires(amount > 0)
    {
        // Check for zero address
        if (recipient == 0x0000000000000000000000000000000000000000) {
            return error.InvalidAddress;
        }
        
        // Check balance
        if (balance < amount) {
            // Return error with parameters
            return InsufficientBalance(amount, balance);
        }
        
        // Perform transfer
        balance -= amount;
        return true;
    }
    
    // Function with multiple possible errors
    pub fn admin_operation(amount: u256) -> !bool | Unauthorized | InvalidAmount {
        // Check authorization
        if (std.transaction.sender != owner) {
            return Unauthorized(std.transaction.sender, owner);
        }
        
        // Check amount
        if (amount == 0) {
            return InvalidAmount(amount);
        }
        
        return true;
    }
    
    // Function that handles errors with try/catch
    pub fn safe_transfer(to: address, amount: u256) -> bool {
        try {
            // Attempt transfer
            var transfer_result: bool = transfer(to, amount);
            return transfer_result;
        } catch (error) {
            // Handle specific error types
            switch (error) {
                InsufficientBalance => {
                    // Log insufficient balance
                    return false;
                },
                InvalidAddress => {
                    // Log invalid address
                    return false;
                },
                else => {
                    // Handle any other errors
                    return false;
                }
            }
        }
    }
    
    // Function that propagates errors
    pub fn proxy_transfer(to: address, amount: u256) -> !bool | InsufficientBalance | InvalidAddress {
        // This will propagate any errors from transfer
        return transfer(to, amount);
    }
    
    // Function with custom error handling logic
    pub fn batch_transfer(recipients: [address; 5], amounts: [u256; 5]) -> u256 {
        var success_count: u256 = 0;
        var failed_count: u256 = 0;
        
        for (recipients) |recipient, i| {
            var amount: u256 = amounts[i];
            
            // Try transfer and handle errors
            try {
                var transfer_result: bool = transfer(recipient, amount);
                if (transfer_result) {
                    success_count += 1;
                } else {
                    failed_count += 1;
                }
            } catch (err) {
                failed_count += 1;
                continue; // Skip to next iteration
            }
        }
        
        // ABI return types are limited; return success_count for now.
        return success_count;
    }
    
    // Function with inline error creation
    pub fn verify_operation(value: u256) -> !bool {
        if (value == 0) {
            return error.ZeroValueNotAllowed;
        }
        
        if (value > 1000) {
            return error.ValueTooLarge;
        }
        
        return true;
    }
}
