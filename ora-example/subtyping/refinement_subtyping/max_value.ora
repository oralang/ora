// ============================================================================
// MaxValue Subtyping Rules
// ============================================================================
// Rule: MaxValue<T, LOWER_MAX> <: MaxValue<T, HIGHER_MAX>
// Lower maximum is a subtype of higher maximum (more restrictive -> less restrictive)
// ============================================================================

contract MaxValueSubtyping {
    // ============================================================================
    // Valid: Lower max to higher max (widening)
    // ============================================================================
    
    // MaxValue<u256, 500> should be assignable to MaxValue<u256, 1000>
    fn testLowerMaxToHigherMax(limit: MaxValue<u256, 500>) -> MaxValue<u256, 1000> {
        return limit; // Valid: 500 <= 1000
    }
    
    // MaxValue<u256, 100> should be assignable to MaxValue<u256, 10000>
    fn testVeryLowMaxToHighMax(limit: MaxValue<u256, 100>) -> MaxValue<u256, 10000> {
        return limit; // Valid: 100 <= 10000
    }
    
    // ============================================================================
    // Function Parameters (Subtyping in)
    // ============================================================================
    
    // Function accepting MaxValue<u256, 1000> should accept MaxValue<u256, 500>
    fn acceptMaxValue1000(limit: MaxValue<u256, 1000>) {
        // Should accept values <= 1000
    }
    
    fn testSubtypingIn() {
        let limit: MaxValue<u256, 500> = 500;
        acceptMaxValue1000(limit); // Valid: 500 <= 1000
    }
    
    // ============================================================================
    // Variable Assignments
    // ============================================================================
    
    fn testVariableAssignment() {
        let lower: MaxValue<u256, 100> = 100;
        let higher: MaxValue<u256, 1000> = lower; // Valid: 100 <= 1000
    }
}
