// ============================================================================
// Invalid Subtyping: Incompatible Refinement Types
// ============================================================================
// These tests SHOULD FAIL COMPILATION
// Different refinement types are not subtypes of each other
// ============================================================================
// NOTE: Comment out the invalid lines to test compilation
// ============================================================================

contract IncompatibleRefinements {
    // ============================================================================
    // Invalid: MinValue to Exact
    // ============================================================================
    
    // ERROR: MinValue cannot convert to Exact (incompatible refinements)
    fn testMinValueToExact(amount: MinValue<u256, 1000>) {
        // const exact: Exact<u256> = amount; // ERROR: Incompatible
    }
    
    // ============================================================================
    // Invalid: BasisPoints to Exact
    // ============================================================================
    
    // ERROR: BasisPoints cannot convert to Exact (incompatible refinements)
    fn testBasisPointsToExact(rate: BasisPoints<u256>) {
        // const exact: Exact<u256> = rate; // ERROR: Incompatible
    }
    
    // ============================================================================
    // Invalid: Exact to MinValue
    // ============================================================================
    
    // ERROR: Exact cannot convert to MinValue (incompatible refinements)
    fn testExactToMinValue(total: Exact<u256>) {
        // const min_value: MinValue<u256, 100> = total; // ERROR: Incompatible
    }
    
    // ============================================================================
    // Invalid: Scaled to MinValue
    // ============================================================================
    
    // ERROR: Scaled cannot convert to MinValue (incompatible refinements)
    fn testScaledToMinValue(amount: Scaled<u256, 18>) {
        // const min_value: MinValue<u256, 1000> = amount; // ERROR: Incompatible
    }
    
    // ============================================================================
    // Invalid: MinValue to Scaled
    // ============================================================================
    
    // ERROR: MinValue cannot convert to Scaled (incompatible refinements)
    fn testMinValueToScaled(amount: MinValue<u256, 1000>) {
        // const scaled: Scaled<u256, 18> = amount; // ERROR: Incompatible
    }
    
    // ============================================================================
    // Invalid: Different base types
    // ============================================================================
    
    // ERROR: u8 cannot convert to MinValue<u256, ...> (base type mismatch)
    fn testWrongBaseType(value: u8) {
        // const min_value: MinValue<u256, 100> = value; // ERROR: Base type mismatch
    }
    
    // ERROR: address cannot convert to MinValue<u256, ...> (completely different types)
    fn testAddressToMinValue(addr: address) {
        // const min_value: MinValue<u256, 100> = addr; // ERROR: Type mismatch
    }
}
