// ERC20 Token with Formal Verification
// Testing FV features on a real contract

contract VerifiedToken {
    // Storage
    storage totalSupply: u256;
    storage balances: map[address, u256];
    storage allowances: doublemap[address, address, u256];
    
    // Contract invariants (specification-only)
    invariant totalSupplyPositive(totalSupply >= 0);
    
    // Ghost variable to track sum of all balances
    ghost storage sumOfBalances: u256;
    
    // Initialize with supply (call once at deployment)
    pub fn initialize(initialSupply: u256) -> bool
        requires(initialSupply > 0)
        ensures(totalSupply == initialSupply)
        ensures(balances[std.msg.sender()] == initialSupply)
    {
        let deployer = std.msg.sender();
        totalSupply = initialSupply;
        balances[deployer] = initialSupply;
        return true;
    }
    
    // Get total supply
    pub fn getTotalSupply() -> u256 {
        return totalSupply;
    }
    
    // Get balance of an account
    pub fn balanceOf(account: address) -> u256 {
        return balances[account];
    }
    
    // Transfer tokens from sender to recipient
    pub fn transfer(recipient: address, amount: u256) -> bool
        requires(amount > 0)
        requires(recipient != std.constants.ZERO_ADDRESS)
        requires(balances[std.msg.sender()] >= amount)
        ensures(balances[std.msg.sender()] == old(balances[std.msg.sender()]) - amount)
        ensures(balances[recipient] == old(balances[recipient]) + amount)
    {
        let sender = std.msg.sender();
        let senderBalance = balances[sender];
        
        // Simple checks without require
        if (senderBalance < amount) {
            return false;
        }
        
        if (recipient == std.constants.ZERO_ADDRESS) {
            return false;
        }
        
        // Perform transfer
        balances[sender] = senderBalance - amount;
        let recipientBalance = balances[recipient];
        balances[recipient] = recipientBalance + amount;
        
        return true;
    }
    
    // Approve spender to spend tokens
    pub fn approve(spender: address, amount: u256) -> bool
        requires(spender != std.constants.ZERO_ADDRESS)
        ensures(allowances[std.msg.sender()][spender] == amount)
    {
        let owner = std.msg.sender();
        
        if (spender == std.constants.ZERO_ADDRESS) {
            return false;
        }
        
        allowances[owner][spender] = amount;
        return true;
    }
    
    // Get allowance
    pub fn allowance(owner: address, spender: address) -> u256 {
        return allowances[owner][spender];
    }
    
    // Transfer from one address to another using allowance
    pub fn transferFrom(sender: address, recipient: address, amount: u256) -> bool
        requires(amount > 0)
        requires(recipient != std.constants.ZERO_ADDRESS)
        requires(allowances[sender][std.msg.sender()] >= amount)
        requires(balances[sender] >= amount)
        ensures(balances[sender] == old(balances[sender]) - amount)
        ensures(balances[recipient] == old(balances[recipient]) + amount)
        ensures(allowances[sender][std.msg.sender()] == old(allowances[sender][std.msg.sender()]) - amount)
    {
        let spender = std.msg.sender();
        
        let currentAllowance = allowances[sender][spender];
        if (currentAllowance < amount) {
            return false;
        }
        
        let senderBalance = balances[sender];
        if (senderBalance < amount) {
            return false;
        }
        
        if (recipient == std.constants.ZERO_ADDRESS) {
            return false;
        }
        
        // Update allowance
        allowances[sender][spender] = currentAllowance - amount;
        
        // Perform transfer
        balances[sender] = senderBalance - amount;
        let recipientBalance = balances[recipient];
        balances[recipient] = recipientBalance + amount;
        
        return true;
    }
    
    // Ghost function to calculate total supply (specification-only)
    ghost fn calculateTotalSupply() -> u256 {
        return sumOfBalances;
    }
}

