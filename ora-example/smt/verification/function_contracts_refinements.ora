// ============================================================================
// Formal Verification: Function Contracts with Refinement Types
// ============================================================================
// Tests requires/ensures clauses with refinement types
// ============================================================================

contract FunctionContractsRefinements {
    storage var balance: MinValue<u256, 0> = 0;
    storage var max_balance: MinValue<u256, 100> = 1000;

    // Requires with refinement type parameter
    pub fn depositRefined(amount: MinValue<u256, 1>)
        requires(amount >= 1)
        ensures(balance >= old(balance))
    {
        let base_amount: u256 = amount;
        balance = balance + base_amount;
    }

    // Ensures returning refinement type
    pub fn getRefinedBalance() -> MinValue<u256, 0>
        ensures(balance >= 0)
    {
        return balance;
    }

    // Requires and ensures with InRange
    pub fn setPercentage(rate: InRange<u256, 0, 100>)
        requires(rate >= 0)
        requires(rate <= 100)
        ensures(rate >= 0)
        ensures(rate <= 100)
    {
        // Rate is already constrained by type
        let _: u256 = rate;
    }

    // Requires with NonZeroAddress
    pub fn setOwner(owner: NonZeroAddress)
        requires(owner != std.constants.ZERO_ADDRESS)
        ensures(owner != std.constants.ZERO_ADDRESS)
    {
        let _: address = owner;
    }

    // Requires proving refinement constraint
    pub fn transferRefined(amount: MinValue<u256, 100>)
        requires(amount >= 100)
        requires(amount <= balance)
        ensures(balance == old(balance) - amount)
    {
        let base_amount: u256 = amount;
        balance = balance - base_amount;
    }

    // Ensures with refinement in return
    pub fn calculateFee(amount: MinValue<u256, 100>, rate: InRange<u256, 0, 100>) -> MinValue<u256, 0>
        requires(amount >= 100)
        requires(amount <= std.constants.U256_MAX / 100)
        requires(rate >= 0)
        requires(rate <= 100)
    {
        let base_amount: u256 = amount;
        let base_rate: u256 = rate;
        let fee: u256 = base_amount * base_rate / 100;
        return fee;
    }
}
