 // ============================================================================
  // Formal Verification: Ghost Functions and Variables Combined
  // ============================================================================
  // Tests ghost functions and variables working together
  // ============================================================================

  contract GhostCombined {
    storage var balance: u256 = 0;
    storage var max_balance: u256 = 1000;

    // Ghost variables
    ghost storage var sumOfBalances: u256 = 0;
    ghost storage var transactionCount: u256 = 0;
    ghost storage var averageTransaction: u256 = 0;

    // Regular storage used in countToN
    storage var counter: u256 = 0;

    // Ghost function using ghost variables
    ghost fn getTotalBalance() -> u256 {
        let total: struct { value: u256, overflow: bool } = @addWithOverflow(balance, sumOfBalances);
        if (total.overflow) {
            return std.constants.U256_MAX;
        }
        return total.value;
    }

    // Ghost function calculating average
    ghost fn getAverageTransaction() -> u256 {
        if (transactionCount == 0) {
            return 0;
        }
        return sumOfBalances / transactionCount;
    }

    // Regular function updating ghost variables and using ghost function
    pub fn deposit(amount: u256)
        requires(amount > 0)
        requires(balance <= max_balance)
        requires(amount <= max_balance - balance)
        requires(sumOfBalances <= std.constants.U256_MAX - amount)
        requires(transactionCount < std.constants.U256_MAX)
        ensures(balance == old(balance) + amount)
        ensures(sumOfBalances == old(sumOfBalances) + amount)
        ensures(transactionCount == old(transactionCount) + 1)
    {
        balance = balance + amount;
        sumOfBalances = sumOfBalances + amount;
        transactionCount = transactionCount + 1;
        averageTransaction = getAverageTransaction();
    }

    // Ghost function with old() referencing ghost variables
    ghost fn getOldTotalBalance() -> u256 {
        let total: struct { value: u256, overflow: bool } = @addWithOverflow(old(balance), old(sumOfBalances));
        if (total.overflow) {
            return std.constants.U256_MAX;
        }
        return total.value;
    }

    // Function using ghost function with old()
    pub fn transfer(amount: u256)
        requires(amount > 0)
        requires(amount <= balance)
        requires(balance <= std.constants.U256_MAX - sumOfBalances)
        ensures(balance == old(balance) - amount)
    {
        balance = balance - amount;
    }

    // Multiple ghost functions working together
    ghost fn getBalanceRatio() -> u256 {
        if (max_balance == 0) {
            return 0;
        }
        if (balance > std.constants.U256_MAX / 100) {
            return 100;
        }
        return balance * 100 / max_balance;
    }

    ghost fn isBalanceHealthy() -> bool {
        return getBalanceRatio() <= 80;
    }

    // Function using multiple ghost functions
    pub fn checkHealth() {
        if (!isBalanceHealthy()) {
            // Balance too high, take action
        }
    }

    // Ghost function with refinement types
    ghost storage var verifiedSum: MinValue<u256, 0> = 0;

    ghost fn getVerifiedTotal() -> MinValue<u256, 0> {
        return verifiedSum;
    }

    // Function using ghost function with refinement
    pub fn updateVerifiedSum(value: MinValue<u256, 0>)
        requires(value >= 0)
        ensures(verifiedSum == value)
        ensures(verifiedSum >= 0)
    {
        verifiedSum = value;
    }

    // Ghost function in loop invariant
    ghost fn expectedCounterValue(iterations: u256) -> u256 {
        return iterations;
    }

    // Function with ghost function in loop
    pub fn countToN(n: u256)
        requires(n <= 100)
    {
        counter = 0;
        var i: u256 = 0;

        while (i < n)
            invariant(counter == i)
        {
            counter = counter + 1;
            i = i + 1;
        }
    }
}
