// ============================================================================
// SMT Guard Test: MaxValue Runtime
// ============================================================================
// Tests that runtime guards are inserted when SMT cannot prove MaxValue
// constraints. Guards should remain in MLIR output.
//
// Run with: --verify --emit-mlir-sir
// Expected: Guards remain in MLIR output (runtime check required)
// ============================================================================

contract MaxValueRuntime {
    storage var stored_value: u256;

    // SMT cannot prove MaxValue - no requires clause
    pub fn runtimeMaxValue100(value: MaxValue<u256, 100>) {
        // Guard should remain - no requires clause to prove constraint
        let v: MaxValue<u256, 100> = value;
    }

    // SMT cannot prove MaxValue - requires clause insufficient
    pub fn runtimeMaxValueInsufficient(value: MaxValue<u256, 100>)
        requires(value <= 200)
    {
        // Guard should remain - value <= 200 does not imply value <= 100
        let v: MaxValue<u256, 100> = value;
    }

    // SMT cannot prove MaxValue from storage
    pub fn runtimeMaxValueFromStorage() {
        // Guard should remain - storage value unknown at compile time
        let v: MaxValue<u256, 100> = stored_value;
    }

    // SMT cannot prove MaxValue from function call
    pub fn runtimeMaxValueFromCall() -> u256 {
        return 0;
    }

    pub fn testCall() {
        let call_result: u256 = runtimeMaxValueFromCall();
        // Guard should remain - function return value unknown
        let v: MaxValue<u256, 100> = call_result;
    }

    // SMT cannot prove MaxValue from arithmetic result
    pub fn runtimeMaxValueArithmetic(x: u256, y: u256) {
        let sum: u256 = x + y;
        // Guard should remain - sum may be > 100
        let v: MaxValue<u256, 100> = sum;
    }

    // SMT cannot prove MaxValue in conditional
    pub fn runtimeMaxValueConditional(x: u256) {
        if (x < 200) {
            // Guard should remain - even though x < 200, we need x <= 100
            let v: MaxValue<u256, 100> = x;
        }
    }
}
