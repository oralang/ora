// ============================================================================
// SMT Guard Test: NonZeroAddress Runtime
// ============================================================================
// Tests that runtime guards are inserted when SMT cannot prove NonZeroAddress
// constraints. Guards should remain in MLIR output.
//
// Run with: --verify --emit-mlir-sir
// Expected: Guards remain in MLIR output (runtime check required)
// ============================================================================

contract NonZeroAddressRuntime {
    // SMT cannot prove NonZeroAddress - no requires clause
    pub fn runtimeNonZeroAddress(addr: NonZeroAddress) {
        // Guard should remain - no requires clause to prove non-zero
        let owner: NonZeroAddress = addr;
    }

    // SMT cannot prove NonZeroAddress from storage
    pub fn runtimeNonZeroFromStorage() {
        storage var stored_addr: address;
        // Guard should remain - storage value unknown at compile time
        let owner: NonZeroAddress = stored_addr;
    }

    // SMT cannot prove NonZeroAddress from function call
    pub fn getAddress() -> address {
        storage var addr: address;
        return addr;
    }

    pub fn testCall() {
        let addr: address = getAddress();
        // Guard should remain - function return value unknown
        let owner: NonZeroAddress = addr;
    }

    // SMT cannot prove NonZeroAddress from function parameter (address, not NonZeroAddress)
    pub fn runtimeNonZeroFromAddressParam(addr: address) {
        // Guard should remain - addr may be zero
        let owner: NonZeroAddress = addr;
    }

    // SMT cannot prove NonZeroAddress from arithmetic (if address arithmetic exists)
    // Note: Address arithmetic is not typical, but testing edge case
    pub fn runtimeNonZeroFromArithmetic(x: address, y: address) {
        // This may not be valid syntax, but testing concept
        // Guard should remain if this is valid
    }
}

