// ============================================================================
// SMT Guard Test: MinValue Runtime
// ============================================================================
// Tests that runtime guards are inserted when SMT cannot prove MinValue
// constraints. Guards should remain in MLIR output.
//
// Run with: --verify --emit-mlir-sir
// Expected: Guards remain in MLIR output (runtime check required)
// ============================================================================

contract MinValueRuntime {
    // SMT cannot prove MinValue - no requires clause
    pub fn runtimeMinValue10(value: MinValue<u256, 10>) {
        // Guard should remain - no requires clause to prove constraint
        let v: MinValue<u256, 10> = value;
    }

    // SMT cannot prove MinValue - requires clause insufficient
    pub fn runtimeMinValueInsufficient(value: MinValue<u256, 100>)
        requires(value >= 50)
    {
        // Guard should remain - value >= 50 does not imply value >= 100
        let v: MinValue<u256, 100> = value;
    }

    // SMT cannot prove MinValue from storage
    pub fn runtimeMinValueFromStorage() {
        storage var stored_value: u256;
        // Guard should remain - storage value unknown at compile time
        let v: MinValue<u256, 100> = stored_value;
    }

    // SMT cannot prove MinValue from function call
    pub fn runtimeMinValueFromCall() -> u256 {
        return 0;
    }

    pub fn testCall() {
        let call_result: u256 = runtimeMinValueFromCall();
        // Guard should remain - function return value unknown
        let v: MinValue<u256, 100> = call_result;
    }

    // SMT cannot prove MinValue from arithmetic result
    pub fn runtimeMinValueArithmetic(x: u256, y: u256) {
        let sum: u256 = x + y;
        // Guard should remain - sum may be < 100
        let v: MinValue<u256, 100> = sum;
    }

    // SMT cannot prove MinValue in conditional
    pub fn runtimeMinValueConditional(x: u256) {
        if (x > 50) {
            // Guard should remain - even though x > 50, we need x >= 100
            let v: MinValue<u256, 100> = x;
        }
    }
}

