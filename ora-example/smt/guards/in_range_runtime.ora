// ============================================================================
// SMT Guard Test: InRange Runtime
// ============================================================================
// Tests that runtime guards are inserted when SMT cannot prove InRange
// constraints. Guards should remain in MLIR output.
//
// Run with: --verify --emit-mlir-sir
// Expected: Guards remain in MLIR output (runtime check required)
// ============================================================================

contract InRangeRuntime {
    storage var stored_value: u256;

    // SMT cannot prove InRange - no requires clause
    pub fn runtimeInRange0to100(value: InRange<u256, 0, 100>) {
        // Guard should remain - no requires clause to prove constraint
        let v: InRange<u256, 0, 100> = value;
    }

    // SMT cannot prove InRange - requires clause insufficient (lower bound)
    pub fn runtimeInRangeInsufficientLower(value: InRange<u256, 100, 1000>)
        requires(value <= 1000)
    {
        // Guard should remain - missing lower bound check
        let v: InRange<u256, 100, 1000> = value;
    }

    // SMT cannot prove InRange - requires clause insufficient (upper bound)
    pub fn runtimeInRangeInsufficientUpper(value: InRange<u256, 100, 1000>)
        requires(value >= 100)
    {
        // Guard should remain - missing upper bound check
        let v: InRange<u256, 100, 1000> = value;
    }

    // SMT cannot prove InRange from storage
    pub fn runtimeInRangeFromStorage() {
        // Guard should remain - storage value unknown at compile time
        let v: InRange<u256, 0, 100> = stored_value;
    }

    // SMT cannot prove InRange from function call
    pub fn runtimeInRangeFromCall() -> u256 {
        return 0;
    }

    pub fn testCall() {
        let call_result: u256 = runtimeInRangeFromCall();
        // Guard should remain - function return value unknown
        let v: InRange<u256, 0, 100> = call_result;
    }

    // SMT cannot prove InRange from arithmetic result
    pub fn runtimeInRangeArithmetic(x: u256, y: u256) {
        let sum: u256 = x + y;
        // Guard should remain - sum may be outside [0, 100]
        let v: InRange<u256, 0, 100> = sum;
    }

    // SMT cannot prove BasisPoints
    pub fn runtimeBasisPoints(fee: u256) {
        // Guard should remain - fee may be outside [0, 10000]
        let v: BasisPoints<u256> = fee;
    }
}
