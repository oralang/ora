// State Analysis Test Contract
// This contract tests various storage access patterns

contract StateTest {
    // Storage variables
    storage counter: u256;
    storage balances: map<address, u256>;
    storage owner: address;
    storage config: u256;
    storage unusedData: u256;
    
    // 1. Stateless function (pure computation, no storage access)
    pub fn add(a: u256, b: u256) -> u256
        requires(a <= std.constants.U256_MAX - b)
    {
        return a + b;
    }
    
    // 2. Readonly function (only reads storage)
    pub fn getCounter() -> u256 {
        return counter;
    }
    
    // 3. Readonly function with multiple reads
    pub fn getBalance(account: address) -> u256 {
        var balance: u256 = balances[account];
        var currentOwner: address = owner;
        return balance;
    }
    
    // 4. Write-only function (only writes storage)
    pub fn setCounter(value: u256) {
        counter = value;
    }
    
    // 5. Read-Write function (reads then writes)
    pub fn incrementCounter()
        requires(counter < std.constants.U256_MAX)
    {
        var current: u256 = counter;
        counter = current + 1;
    }
    
    // 6. Complex function with multiple reads and writes
    pub fn transfer(from: address, recipient: address, amount: u256)
        requires(from != recipient)
        requires(balances[from] >= amount)
        requires(balances[recipient] <= std.constants.U256_MAX - amount)
    {
        var fromBalance: u256 = balances[from];
        var toBalance: u256 = balances[recipient];
        
        balances[from] = fromBalance - amount;
        balances[recipient] = toBalance + amount;
    }
    
    // 7. Function that only reads (never writes)
    pub fn checkBalance(account: address) -> bool {
        return balances[account] > 0;
    }
    
    // 8. Function with conditional reads
    pub fn getBalanceOrDefault(account: address, useDefault: bool) -> u256 {
        if (useDefault) {
            return 100;
        }
        return balances[account];
    }
    
    // 9. Function with storage read
    pub fn sumBalances(account: address) -> u256 {
        return balances[account];
    }
    
    // 10. Dead store (writes but value never read)
    pub fn writeUnused(value: u256) {
        unusedData = value;
    }
    
    // 11. Function that reads multiple variables
    pub fn getOwnerBalance() -> u256 {
        var currentOwner: address = owner;
        return balances[currentOwner];
    }
    
    // 12. Function with nested reads
    pub fn complexRead() -> u256
        requires(counter <= std.constants.U256_MAX - config)
    {
        var a: u256 = counter;
        var b: u256 = config;
        return a + b;
    }
    
    // 13. Write without prior read
    pub fn initialize(initialOwner: address) {
        owner = initialOwner;
        counter = 0;
    }
    
    // 14. Mixed stateless and readonly
    pub fn calculateFee(amount: u256) -> u256 {
        var fee: u256 = amount / 100;  // Stateless computation
        var min_fee: u256 = config;     // Storage read
        if (fee < min_fee) {
            return min_fee;
        }
        return fee;
    }
    
    // 15. Function that modifies multiple storage variables
    pub fn reset() {
        counter = 0;
        config = 0;
    }
    
    // 16. Function that reads and writes multiple variables
    pub fn updateConfigFromCounter()
        requires(counter < std.constants.U256_MAX)
        requires(config <= std.constants.U256_MAX / 2)
    {
        var currentCounter: u256 = counter;  // Read from counter
        var currentConfig: u256 = config;    // Read from config
        
        config = currentCounter;   // Write to config
        counter = currentConfig;   // Write to counter
    }
    
    // 17. Function with cross-variable logic (read 2, write 2)
    pub fn swapCounterAndConfig() {
        var temp: u256 = counter;            // Read counter
        counter = config;              // Read config, Write counter
        config = temp;                 // Write config
    }
}
