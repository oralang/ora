// Minimal ERC20 Token Implementation in Ora
// Using only currently available features

contract SimpleToken {
    // Storage
    storage totalSupply: u256;
    storage balances: map[address, u256];
    storage allowances: doublemap[address, address, u256];
    
    // Constructor - runs once at deployment
    pub fn init(initialSupply: u256) {
        let deployer = std.msg.sender();
        totalSupply = initialSupply;
        balances[deployer] = initialSupply;
    }
    
    // Initialize with supply (can be called after deployment)
    pub fn initialize(initialSupply: u256) -> bool {
        let deployer = std.msg.sender();
        totalSupply = initialSupply;
        balances[deployer] = initialSupply;
        return true;
    }
    
    // Get total supply
    pub fn getTotalSupply() -> u256 {
        return totalSupply;
    }
    
    // Get balance of an account
    pub fn balanceOf(account: address) -> u256 {
        return balances[account];
    }
    
    // Transfer tokens from sender to recipient
    pub fn transfer(recipient: address, amount: u256) -> bool {
        let sender = std.msg.sender();
        let senderBalance = balances[sender];
        
        // Simple checks without require
        if (senderBalance < amount) {
            return false;
        }
        
        if (recipient == std.constants.ZERO_ADDRESS) {
            return false;
        }
        
        // Perform transfer
        balances[sender] = senderBalance - amount;
        let recipientBalance = balances[recipient];
        balances[recipient] = recipientBalance + amount;
        
        return true;
    }
    
    // Approve spender to spend tokens
    pub fn approve(spender: address, amount: u256) -> bool {
        let owner = std.msg.sender();
        
        if (spender == std.constants.ZERO_ADDRESS) {
            return false;
        }
        
        allowances[owner][spender] = amount;
        return true;
    }
    
    // Get allowance
    pub fn allowance(owner: address, spender: address) -> u256 {
        return allowances[owner][spender];
    }
    
    // Transfer from one address to another using allowance
    pub fn transferFrom(sender: address, recipient: address, amount: u256) -> bool {
        let spender = std.msg.sender();
        
        let currentAllowance = allowances[sender][spender];
        if (currentAllowance < amount) {
            return false;
        }
        
        let senderBalance = balances[sender];
        if (senderBalance < amount) {
            return false;
        }
        
        if (recipient == std.constants.ZERO_ADDRESS) {
            return false;
        }
        
        // Update allowance
        allowances[sender][spender] = currentAllowance - amount;
        
        // Perform transfer
        balances[sender] = senderBalance - amount;
        let recipientBalance = balances[recipient];
        balances[recipient] = recipientBalance + amount;
        
        return true;
    }
}

