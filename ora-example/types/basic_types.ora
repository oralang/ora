// ==========================================
// TYPES TEST
// ==========================================
// This file tests various type declarations and type operations

// Top-level type declarations
struct CustomType {
    value: u256;
    name: string;
}

enum StatusType : u8 {
    Active = 0,
    Inactive = 1
}

contract TypesTest {
    // Testing primitive types
    storage var u8_value: u8;
    storage var u16_value: u16;
    storage var u32_value: u32;
    storage var u64_value: u64;
    storage var u128_value: u128;
    storage var u256_value: u256;
    storage var bool_value: bool;
    storage var address_value: address;
    storage var string_value: string;
    storage var bytes_value: bytes;
    
    // Testing complex types
    storage var map_value: map[address, u256];
    storage var doublemap_value: doublemap[address, u8, u256];
    storage var struct_value: CustomType;
    storage var enum_value: StatusType;
    
    pub fn init() {
        // Initialize primitive types
        u8_value = 255;
        u16_value = 65535;
        u32_value = 4294967295;
        u64_value = 18446744073709551615;
        u128_value = 340282366920938463463374607431768211455;
        u256_value = 115792089237316195423570985008687907853269984665640564039457584007913129639935;
        bool_value = true;
        address_value = 0x1234567890123456789012345678901234567890;
        string_value = "Hello, World!";
        bytes_value = hex"01020304";
        
        // Initialize complex types
        enum_value = StatusType.Active;
    }
    
    // Type checking examples
    pub fn test_type_checking(value: u256) -> bool {
        // Range checking
        if (value > 100) {
            return false;
        }
        
        // Enum type checking
        let status: StatusType = StatusType.Active;
        if (status == StatusType.Active) {
            return true;
        }
        
        return false;
    }
    
    // Map type operations
    pub fn test_map_operations() -> u256 {
        // Map usage
        map_value[address_value] = 100;
        
        // Map access
        let val = map_value[address_value];
        
        // Double map usage
        doublemap_value[address_value, 1] = 200;
        
        // Double map access
        let dval = doublemap_value[address_value, 1];
        
        return val + dval;
    }
}
