// ==========================================
// ANNOTATIONS PARSER TEST
// ==========================================
// This file tests annotations, requires, ensures, and quantifiers

contract AnnotationTest {
    // Lock annotation for thread-safe access
    @lock
    storage var protected_balance: u256;
    
    @lock
    storage var shared_counter: u256;
    
    // Regular storage without lock
    storage var regular_balance: u256;
    storage var balances: map[address, u256];
    
    // Inline function annotation
    @inline
    pub fn inline_function(x: u256) u256 {
        return x * 2;
    }
    
    // Function with requires and ensures
    pub fn test_requires_ensures(input: u256) u256
        requires(input > 0)                    // Precondition
        requires(input < 1000000)              // Multiple preconditions
        ensures(result > input)                // Postcondition
        ensures(result <= input * 2)          // Multiple postconditions
    {
        return input + 1;
    }
    
    // Function with complex requires/ensures
    pub fn transfer_with_verification(
        to: address, 
        amount: u256
    ) bool
        requires(amount > 0)                                    // Amount must be positive
        requires(to != 0x0000000000000000000000000000000000000000) // Valid recipient
        requires(regular_balance >= amount)                     // Sufficient balance
        ensures(old(regular_balance) == regular_balance + amount) // Balance correctly updated
        ensures(result == true)                                 // Function succeeds
    {
        regular_balance -= amount;
        return true;
    }
    
    // Function with quantified expressions in ensures
    pub fn batch_update(addresses: [address], amounts: [u256]) bool
        requires(addresses.len() == amounts.len())              // Arrays same length
        requires(addresses.len() > 0)                          // At least one address
        requires(forall i: u256 where i < amounts.len() => amounts[i] > 0) // All amounts positive
        ensures(forall i: u256 where i < addresses.len() => 
            balances[addresses[i]] >= old(balances[addresses[i]])) // All balances increased
    {
        for (addresses) |addr, i| {
            balances[addr] += amounts[i];
        }
        return true;
    }
    
    // Function with exists quantifier
    pub fn has_large_balance(threshold: u256) bool
        ensures(result == exists addr: address => balances[addr] > threshold)
    {
        // Implementation would check if any address has balance > threshold
        return balances[std.transaction.sender] > threshold;
    }
    
    // Function with old() expressions in ensures
    pub fn increment_with_history() u256
        ensures(result == old(shared_counter) + 1)
        ensures(shared_counter == old(shared_counter) + 1)
    {
        shared_counter += 1;
        return shared_counter;
    }
    
    // Function with invariant (loop invariant)
    pub fn sum_array(arr: [u256]) u256 {
        let mut sum: u256 = 0;
        let mut i: u256 = 0;
        
        while (i < arr.len())
            invariant(sum == sum_of_first_i_elements(arr, i))  // Loop invariant
            invariant(i <= arr.len())                          // Bounds invariant
        {
            sum += arr[i];
            i += 1;
        }
        
        return sum;
    }
    
    // Multiple annotations on single function
    @inline
    pub fn optimized_calculation(x: u256, y: u256) u256
        requires(x > 0 && y > 0)
        ensures(result >= x && result >= y)
    {
        return if (x > y) x else y;
    }
    
    // Annotation with parameters (if supported)
    @gas_limit(50000)
    pub fn gas_limited_function() bool {
        return true;
    }
    
    // Pure function annotation (no state changes)
    @pure
    pub fn pure_calculation(a: u256, b: u256) u256 {
        return a + b;
    }
    
    // View function annotation (read-only)
    @view
    pub fn view_balance(addr: address) u256 {
        return balances[addr];
    }
    
    // Payable function annotation (can receive Ether)
    @payable
    pub fn deposit() bool {
        regular_balance += std.transaction.value;
        return true;
    }
    
    // Storage variable with multiple annotations
    @lock
    @indexed  // For events/logs
    storage var important_value: u256;
    
    // Function with complex preconditions using forall
    pub fn validate_all_positive(values: [u256]) bool
        requires(values.len() > 0)
        requires(forall i: u256 where i < values.len() => values[i] > 0)
        ensures(result == true)
    {
        // All values are guaranteed to be positive due to precondition
        return true;
    }
    
    // Function with exists in precondition
    pub fn process_if_any_large(values: [u256], threshold: u256) bool
        requires(exists i: u256 where i < values.len() && values[i] > threshold)
    {
        // At least one value is guaranteed to be > threshold
        for (values) |value| {
            if (value > threshold) {
                return true;
            }
        }
        return false; // Should never reach here due to precondition
    }
    
    // Helper function for invariant
    fn sum_of_first_i_elements(arr: [u256], count: u256) u256 {
        let mut sum: u256 = 0;
        let mut j: u256 = 0;
        
        while (j < count && j < arr.len()) {
            sum += arr[j];
            j += 1;
        }
        
        return sum;
    }
}