// ==========================================
// SWITCH STATEMENTS PARSER TEST
// ==========================================
// This file tests the parser's ability to handle switch statements
// with various pattern types including ranges, enums, and exhaustiveness

// Enum for testing switch statements
enum Operation : u8 {
    Add = 0,
    Subtract = 1,
    Multiply = 2,
    Divide = 3
}

// Contract demonstrating switch statement usage
contract SwitchTest {
    // Storage variables
    storage var last_result: u256;
    
    // Constructor
    pub fn init() {
        last_result = 0;
    }
    
    // Function with switch on enum values
    pub fn calculate(operation: Operation, a: u256, b: u256) u256 | error {
        // Switch statement with enum pattern matching
        switch (operation) {
            Operation.Add => {
                last_result = a + b;
                return last_result;
            },
            Operation.Subtract => {
                if (a < b) {
                    return error("Underflow");
                }
                last_result = a - b;
                return last_result;
            },
            Operation.Multiply => {
                last_result = a * b;
                return last_result;
            },
            Operation.Divide => {
                if (b == 0) {
                    return error("Division by zero");
                }
                last_result = a / b;
                return last_result;
            }
        }
    }
    
    // Function with switch using numeric range patterns
    pub fn classify_amount(amount: u256) string {
        // Switch expression with range patterns
        return switch (amount) {
            0 => "zero",
            1...100 => "small",
            101...1000 => "medium",
            1001...10000 => "large",
            else => "huge"
        };
    }
    
    // Function with switch on string literals
    pub fn process_command(command: string) bool {
        // Switch statement with string pattern matching
        switch (command) {
            "reset" => {
                last_result = 0;
                return true;
            },
            "double" => {
                last_result = last_result * 2;
                return true;
            },
            "square" => {
                last_result = last_result * last_result;
                return true;
            },
            else => {
                return false;
            }
        }
    }
    
    // Function with labeled blocks and early exit
    pub fn complex_calculation(value: u256) u256 {
        // Labeled block with switch expression
        const result = blk: {
            switch (value) {
                0 => break :blk 0,
                1...10 => break :blk value * 10,
                11...100 => break :blk value * 5,
                else => break :blk value
            }
        };
        
        return result;
    }
}
