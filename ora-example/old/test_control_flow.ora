// ==========================================
// CONTROL FLOW PARSER TEST
// ==========================================
// This file tests all control flow constructs

contract ControlFlowTest {
    storage var counter: u256;
    storage var test_array: [u256];
    storage var conditions: map[u256, bool];
    
    pub fn test_if_else() bool {
        let value = 10;
        
        // Simple if
        if (value > 5) {
            counter += 1;
        }
        
        // If-else
        if (value > 20) {
            return false;
        } else {
            counter += 2;
        }
        
        // If-else if-else chain
        if (value < 5) {
            return false;
        } else if (value < 15) {
            counter += 3;
            return true;
        } else if (value < 25) {
            counter += 4;
            return true;
        } else {
            return false;
        }
    }
    
    pub fn test_while_loop() u256 {
        let mut i: u256 = 0;
        let mut sum: u256 = 0;
        
        // Simple while loop
        while (i < 10) {
            sum += i;
            i += 1;
        }
        
        // While loop with complex condition
        let mut j: u256 = 0;
        while (j < 5 && sum < 100) {
            sum += j * 2;
            j += 1;
        }
        
        // While loop with break and continue
        let mut k: u256 = 0;
        while (k < 20) {
            k += 1;
            
            if (k % 2 == 0) {
                continue;
            }
            
            if (k > 15) {
                break;
            }
            
            sum += k;
        }
        
        return sum;
    }
    
    pub fn test_for_loop() u256 {
        test_array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        let mut sum: u256 = 0;
        
        // Simple for loop with item only
        for (test_array) |item| {
            sum += item;
        }
        
        // For loop with item and index
        for (test_array) |item, index| {
            sum += item * index;
        }
        
        // For loop with range
        for (0..10) |_, i| {
            sum += i;
        }
        
        // For loop with break and continue
        for (test_array) |item, index| {
            if (item % 2 == 0) {
                continue;
            }
            
            if (index > 5) {
                break;
            }
            
            sum += item;
        }
        
        return sum;
    }
    
    pub fn test_labeled_blocks() u256 {
        let result = outer: {
            let mut i: u256 = 0;
            
            while (i < 10) {
                let inner_result = inner: {
                    if (i == 3) {
                        break :inner i * 10;
                    }
                    
                    if (i == 7) {
                        break :outer i * 100;
                    }
                    
                    break :inner i;
                };
                
                if (inner_result > 20) {
                    break :outer inner_result;
                }
                
                i += 1;
            }
            
            break :outer 999;
        };
        
        return result;
    }
    
    pub fn test_nested_loops() u256 {
        let mut total: u256 = 0;
        
        // Nested for loops with labeled break
        outer_loop: for (0..5) |_, i| {
            inner_loop: for (0..5) |_, j| {
                if (i == 2 && j == 3) {
                    break :outer_loop;
                }
                
                if (j == 2) {
                    continue :inner_loop;
                }
                
                total += i * j;
            }
        }
        
        return total;
    }
    
    pub fn test_try_catch() bool {
        try {
            let result = self.might_fail();
            return result;
        } catch error {
            // Handle any error
            return false;
        }
    }
    
    pub fn test_try_catch_with_variable() bool {
        try {
            let result = self.might_fail();
            return result;
        } catch err {
            // Handle error with variable
            return false;
        }
    }
    
    pub fn test_invariant_loop() u256 {
        let mut sum: u256 = 0;
        let mut i: u256 = 0;
        
        while (i < 10)
            invariant(sum >= 0)
            invariant(i <= 10)
        {
            sum += i;
            i += 1;
        }
        
        return sum;
    }
    
    fn might_fail() !bool {
        return true;
    }
}