// ==========================================
// IMPORTS AND MODULES PARSER TEST
// ==========================================
// This file tests import statements and module system

// Standard library imports
const std = @import(\"std\");
const math = @import(\"math\");
const crypto = @import(\"crypto\");

// Local module imports
const utils = @import(\"./utils.ora\");
const types = @import(\"../types/common.ora\");

// Specific imports from modules
const { hash, verify } = @import(\"crypto\");
const { add, multiply } = @import(\"./math_utils.ora\");

contract ImportTest {
    storage var hash_value: bytes;
    storage var computed_value: u256;
    
    pub fn test_std_usage() u256 {
        // Using standard library
        let timestamp = std.block.timestamp;
        let sender = std.transaction.sender;
        let gas_limit = std.transaction.gas_limit;
        
        return timestamp + gas_limit;
    }
    
    pub fn test_math_imports() u256 {
        // Using imported math functions
        let result1 = math.sqrt(16);
        let result2 = add(10, 20);
        let result3 = multiply(5, 6);
        
        return result1 + result2 + result3;
    }
    
    pub fn test_crypto_imports() bytes {
        // Using imported crypto functions
        let data = \"test data\";
        let hashed = hash(data);
        let is_valid = verify(hashed, data);
        
        hash_value = hashed;
        return hashed;
    }
    
    pub fn test_utils_imports() bool {
        // Using local utility functions
        let validated = utils.validate_address(std.transaction.sender);
        let formatted = utils.format_amount(1000);
        
        return validated;
    }
    
    pub fn test_type_imports() types.CustomType {
        // Using imported types
        let custom_val = types.CustomType {
            value: 42,
            name: \"test\"
        };
        
        return custom_val;
    }
}

// Module-level function (not in contract)
pub fn module_level_function(x: u256) u256 {
    return x * 2;
}

// Module-level constant
const MODULE_CONSTANT: u256 = 1000;

// Module-level struct
struct ModuleStruct {
    id: u256;
    active: bool;
}

// Module-level enum
enum ModuleEnum : u8 {
    Option1 = 0,
    Option2 = 1,
    Option3 = 2
}