contract ComplexityTest {
    storage var balance: u256;
    
    // Simple function
    pub fn simple_add(a: u256, b: u256) -> u256
        requires(a < u128_MAX)
        requires(b < u128_MAX)
    {
        return a + b;
    }
    
    // Moderate function
    pub fn moderate_transfer(recipient: address, amount: u256) -> bool
        requires(balance >= amount)
        requires(recipient != std.constants.ZERO_ADDRESS)
    {
        if (amount == 0) {
            return false;
        }
        
        balance -= amount;
        log Transfer(std.transaction.sender, recipient, amount);
        return true;
    }
    
    // Complex function with nested blocks
    inline fn complex_process(data: u256) -> u256 {
        var result: u256 = 0;
        
        if (data > 100) {
            if (data > 1000) {
                result = data * 2;
            } else {
                result = data + 100;
            }
        } else {
            if (data > 10) {
                result = data / 2;
            } else {
                result = data + 1;
            }
        }
        
        var i: u256 = 0;
        while (i < 10) {
            if (result > 50) {
                result -= 1;
            } else {
                result += 1;
            }
            i += 1;
        }
        
        return result;
    }
}

