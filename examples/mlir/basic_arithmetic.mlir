// Expected MLIR output for basic_arithmetic.ora
// Generated by: ora compile --emit-mlir examples/mlir/basic_arithmetic.ora

module {
  func.func @add(%arg0: i256, %arg1: i256) -> i256 {
    %0 = arith.addi %arg0, %arg1 : i256
    return %0 : i256
  } loc("basic_arithmetic.ora":4:1)

  func.func @subtract(%arg0: i256, %arg1: i256) -> i256 {
    %0 = arith.subi %arg0, %arg1 : i256
    return %0 : i256
  } loc("basic_arithmetic.ora":8:1)

  func.func @multiply(%arg0: i256, %arg1: i256) -> i256 {
    %0 = arith.muli %arg0, %arg1 : i256
    return %0 : i256
  } loc("basic_arithmetic.ora":12:1)

  func.func @divide(%arg0: i256, %arg1: i256) -> i256 {
    %0 = arith.divui %arg0, %arg1 : i256
    return %0 : i256
  } loc("basic_arithmetic.ora":16:1)

  func.func @modulo(%arg0: i256, %arg1: i256) -> i256 {
    %0 = arith.remui %arg0, %arg1 : i256
    return %0 : i256
  } loc("basic_arithmetic.ora":20:1)

  func.func @complex_expression(%arg0: i256, %arg1: i256, %arg2: i256) -> i256 {
    %0 = arith.addi %arg0, %arg1 : i256
    %1 = arith.muli %0, %arg2 : i256
    %2 = arith.divui %arg0, %arg1 : i256
    %3 = arith.subi %1, %2 : i256
    return %3 : i256
  } loc("basic_arithmetic.ora":24:1)

  func.func @boolean_operations(%arg0: i1, %arg1: i1) -> i1 {
    %true = arith.constant true
    %0 = scf.if %arg0 -> i1 {
      scf.yield %arg1 : i1
    } else {
      %false = arith.constant false
      scf.yield %false : i1
    }
    %1 = arith.xori %arg0, %true : i1
    %2 = arith.ori %0, %1 : i1
    return %2 : i1
  } loc("basic_arithmetic.ora":28:1)

  func.func @comparison_operations(%arg0: i256, %arg1: i256) -> i1 {
    %c100 = arith.constant 100 : i256
    %0 = arith.cmpi ugt, %arg0, %arg1 : i256
    %1 = arith.addi %arg1, %c100 : i256
    %2 = arith.cmpi ule, %arg0, %1 : i256
    %3 = scf.if %0 -> i1 {
      scf.yield %2 : i1
    } else {
      %false = arith.constant false
      scf.yield %false : i1
    }
    return %3 : i1
  } loc("basic_arithmetic.ora":32:1)
}