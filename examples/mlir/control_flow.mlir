// Expected MLIR output for control_flow.ora
// Generated by: ora compile --emit-mlir examples/mlir/control_flow.ora

module {
  func.func @conditional(%arg0: i256) -> i256 {
    %c100 = arith.constant 100 : i256
    %c2 = arith.constant 2 : i256
    %c10 = arith.constant 10 : i256
    %0 = arith.cmpi ugt, %arg0, %c100 : i256
    %1 = scf.if %0 -> i256 {
      %2 = arith.muli %arg0, %c2 : i256
      scf.yield %2 : i256
    } else {
      %2 = arith.addi %arg0, %c10 : i256
      scf.yield %2 : i256
    }
    return %1 : i256
  } loc("control_flow.ora":4:1)

  func.func @while_loop(%arg0: i256) -> i256 {
    %c0 = arith.constant 0 : i256
    %c1 = arith.constant 1 : i256
    %0:2 = scf.while (%arg1 = %c0, %arg2 = %arg0) : (i256, i256) -> (i256, i256) {
      %1 = arith.cmpi ugt, %arg2, %c0 : i256
      scf.condition(%1) %arg1, %arg2 : i256, i256
    } do {
    ^bb0(%arg1: i256, %arg2: i256):
      %1 = arith.addi %arg1, %arg2 : i256
      %2 = arith.subi %arg2, %c1 : i256
      scf.yield %1, %2 : i256, i256
    }
    return %0#0 : i256
  } loc("control_flow.ora":11:1)

  func.func @for_loop(%arg0: memref<5xi256>) -> i256 {
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c5 = arith.constant 5 : index
    %c0_i256 = arith.constant 0 : i256
    %0 = scf.for %arg1 = %c0 to %c5 step %c1 iter_args(%arg2 = %c0_i256) -> (i256) {
      %1 = memref.load %arg0[%arg1] : memref<5xi256>
      %2 = arith.addi %arg2, %1 : i256
      scf.yield %2 : i256
    }
    return %0 : i256
  } loc("control_flow.ora":20:1)

  func.func @switch_statement(%arg0: i256) -> i256 {
    %c0 = arith.constant 0 : i256
    %c1 = arith.constant 1 : i256
    %c10 = arith.constant 10 : i256
    %c100 = arith.constant 100 : i256
    %c999 = arith.constant 999 : i256
    %c2 = arith.constant 2 : i256
    cf.switch %arg0 : i256, [
      default: ^bb4,
      0: ^bb1,
      100: ^bb3
    ]
  ^bb1:  // case 0
    return %c1 : i256
  ^bb2:  // case 1...10
    %0 = arith.muli %arg0, %c2 : i256
    return %0 : i256
  ^bb3:  // case 100
    return %c999 : i256
  ^bb4:  // else
    %1 = arith.cmpi uge, %arg0, %c1 : i256
    %2 = arith.cmpi ule, %arg0, %c10 : i256
    %3 = arith.andi %1, %2 : i1
    cf.cond_br %3, ^bb2, ^bb5
  ^bb5:  // default case
    return %c0 : i256
  } loc("control_flow.ora":28:1)

  func.func @switch_expression(%arg0: i256) -> i256 {
    %c0 = arith.constant 0 : i256
    %c1 = arith.constant 1 : i256
    %c10 = arith.constant 10 : i256
    %c100 = arith.constant 100 : i256
    %c999 = arith.constant 999 : i256
    %c2 = arith.constant 2 : i256
    %0 = scf.index_switch %arg0 -> i256
    case 0 {
      scf.yield %c1 : i256
    }
    case 100 {
      scf.yield %c999 : i256
    }
    default {
      %1 = arith.cmpi uge, %arg0, %c1 : i256
      %2 = arith.cmpi ule, %arg0, %c10 : i256
      %3 = arith.andi %1, %2 : i1
      %4 = scf.if %3 -> i256 {
        %5 = arith.muli %arg0, %c2 : i256
        scf.yield %5 : i256
      } else {
        scf.yield %c0 : i256
      }
      scf.yield %4 : i256
    }
    return %0 : i256
  } loc("control_flow.ora":37:1)
}