// Expected MLIR output for verification.ora
// Generated by: ora compile --emit-mlir examples/mlir/verification.ora

module {
  // Storage variables
  memref.global "private" @balance : memref<1xi256, 1> {ora.region = "storage"}
  memref.global "private" @total_supply : memref<1xi256, 1> {ora.region = "storage"}

  func.func @transfer(%arg0: i160, %arg1: i256) -> i1 {
    %c0 = arith.constant 0 : i256
    %true = arith.constant true
    
    // Load current values for preconditions and old() expressions
    %balance_ref = memref.get_global @balance : memref<1xi256, 1>
    %total_supply_ref = memref.get_global @total_supply : memref<1xi256, 1>
    %old_balance = memref.load %balance_ref[] : memref<1xi256, 1>
    %old_total_supply = memref.load %total_supply_ref[] : memref<1xi256, 1>
    
    // Precondition: balance >= amount
    %precond1 = arith.cmpi uge, %old_balance, %arg1 : i256
    ora.assert %precond1 {ora.requires = true} : i1
    
    // Precondition: amount > 0
    %precond2 = arith.cmpi ugt, %arg1, %c0 : i256
    ora.assert %precond2 {ora.requires = true} : i1
    
    // Function body
    %new_balance = arith.subi %old_balance, %arg1 : i256
    memref.store %new_balance, %balance_ref[] : memref<1xi256, 1>
    
    // Load final values for postconditions
    %final_balance = memref.load %balance_ref[] : memref<1xi256, 1>
    %final_total_supply = memref.load %total_supply_ref[] : memref<1xi256, 1>
    
    // Postcondition: balance == old(balance) - amount
    %expected_balance = arith.subi %old_balance, %arg1 : i256
    %postcond1 = arith.cmpi eq, %final_balance, %expected_balance : i256
    ora.assert %postcond1 {ora.ensures = true, ora.old = %old_balance} : i1
    
    // Postcondition: total_supply == old(total_supply)
    %postcond2 = arith.cmpi eq, %final_total_supply, %old_total_supply : i256
    ora.assert %postcond2 {ora.ensures = true, ora.old = %old_total_supply} : i1
    
    return %true : i1
  } loc("verification.ora":8:5)

  func.func @mint(%arg0: i256) -> i1 {
    %c0 = arith.constant 0 : i256
    %c1000000 = arith.constant 1000000 : i256
    %true = arith.constant true
    
    // Load current values
    %balance_ref = memref.get_global @balance : memref<1xi256, 1>
    %total_supply_ref = memref.get_global @total_supply : memref<1xi256, 1>
    %old_balance = memref.load %balance_ref[] : memref<1xi256, 1>
    %old_total_supply = memref.load %total_supply_ref[] : memref<1xi256, 1>
    
    // Precondition: amount > 0
    %precond1 = arith.cmpi ugt, %arg0, %c0 : i256
    ora.assert %precond1 {ora.requires = true} : i1
    
    // Precondition: total_supply + amount <= 1_000_000
    %new_total = arith.addi %old_total_supply, %arg0 : i256
    %precond2 = arith.cmpi ule, %new_total, %c1000000 : i256
    ora.assert %precond2 {ora.requires = true} : i1
    
    // Function body
    %new_balance = arith.addi %old_balance, %arg0 : i256
    %new_total_supply = arith.addi %old_total_supply, %arg0 : i256
    memref.store %new_balance, %balance_ref[] : memref<1xi256, 1>
    memref.store %new_total_supply, %total_supply_ref[] : memref<1xi256, 1>
    
    // Load final values
    %final_balance = memref.load %balance_ref[] : memref<1xi256, 1>
    %final_total_supply = memref.load %total_supply_ref[] : memref<1xi256, 1>
    
    // Postcondition: balance == old(balance) + amount
    %expected_balance = arith.addi %old_balance, %arg0 : i256
    %postcond1 = arith.cmpi eq, %final_balance, %expected_balance : i256
    ora.assert %postcond1 {ora.ensures = true, ora.old = %old_balance} : i1
    
    // Postcondition: total_supply == old(total_supply) + amount
    %expected_total = arith.addi %old_total_supply, %arg0 : i256
    %postcond2 = arith.cmpi eq, %final_total_supply, %expected_total : i256
    ora.assert %postcond2 {ora.ensures = true, ora.old = %old_total_supply} : i1
    
    return %true : i1
  } loc("verification.ora":17:5)

  func.func @safe_divide(%arg0: i256, %arg1: i256) -> i256 {
    %c0 = arith.constant 0 : i256
    
    // Precondition: b != 0
    %precond = arith.cmpi ne, %arg1, %c0 : i256
    ora.assert %precond {ora.requires = true} : i1
    
    // Function body
    %result = arith.divui %arg0, %arg1 : i256
    
    // Postcondition: result == a / b
    %expected = arith.divui %arg0, %arg1 : i256
    %postcond = arith.cmpi eq, %result, %expected : i256
    ora.assert %postcond {ora.ensures = true} : i1
    
    return %result : i256
  } loc("verification.ora":28:5)

  func.func @array_sum(%arg0: memref<5xi256>) -> i256 {
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c5 = arith.constant 5 : index
    %c0_i256 = arith.constant 0 : i256
    
    // Precondition: forall(i in 0...5) array[i] >= 0
    %forall_result = ora.forall %i in %c0 to %c5 {
      %elem = memref.load %arg0[%i] : memref<5xi256>
      %non_negative = arith.cmpi uge, %elem, %c0_i256 : i256
      ora.yield %non_negative : i1
    } : (index) -> i1
    ora.assert %forall_result {ora.requires = true, ora.quantified = true} : i1
    
    // Function body - compute sum
    %sum = scf.for %i = %c0 to %c5 step %c1 iter_args(%acc = %c0_i256) -> (i256) {
      %elem = memref.load %arg0[%i] : memref<5xi256>
      %new_acc = arith.addi %acc, %elem : i256
      scf.yield %new_acc : i256
    }
    
    // Postcondition: result >= 0
    %postcond1 = arith.cmpi uge, %sum, %c0_i256 : i256
    ora.assert %postcond1 {ora.ensures = true} : i1
    
    // Postcondition: result == array[0] + array[1] + array[2] + array[3] + array[4]
    %elem0 = memref.load %arg0[%c0] : memref<5xi256>
    %c1_idx = arith.constant 1 : index
    %elem1 = memref.load %arg0[%c1_idx] : memref<5xi256>
    %c2_idx = arith.constant 2 : index
    %elem2 = memref.load %arg0[%c2_idx] : memref<5xi256>
    %c3_idx = arith.constant 3 : index
    %elem3 = memref.load %arg0[%c3_idx] : memref<5xi256>
    %c4_idx = arith.constant 4 : index
    %elem4 = memref.load %arg0[%c4_idx] : memref<5xi256>
    
    %sum01 = arith.addi %elem0, %elem1 : i256
    %sum012 = arith.addi %sum01, %elem2 : i256
    %sum0123 = arith.addi %sum012, %elem3 : i256
    %expected_sum = arith.addi %sum0123, %elem4 : i256
    
    %postcond2 = arith.cmpi eq, %sum, %expected_sum : i256
    ora.assert %postcond2 {ora.ensures = true} : i1
    
    return %sum : i256
  } loc("verification.ora":34:5)
}