// Expected MLIR output for memory_regions.ora
// Generated by: ora compile --emit-mlir examples/mlir/memory_regions.ora

module {
  // Storage variables as global memrefs in storage space (space 1)
  memref.global "private" @balance : memref<1xi256, 1> {ora.region = "storage"}
  memref.global "private" @owner : memref<1xi160, 1> {ora.region = "storage"}

  func.func @storage_operations() -> i256 {
    %c100 = arith.constant 100 : i256
    
    // Load from storage (space 1) to stack
    %balance_ref = memref.get_global @balance : memref<1xi256, 1>
    %current_balance = memref.load %balance_ref[] : memref<1xi256, 1>
    
    // Arithmetic on stack values
    %new_balance = arith.addi %current_balance, %c100 : i256
    
    // Store back to storage (space 1)
    memref.store %new_balance, %balance_ref[] : memref<1xi256, 1>
    
    // Load updated value
    %result = memref.load %balance_ref[] : memref<1xi256, 1>
    return %result : i256
  } loc("memory_regions.ora":8:5)

  func.func @memory_operations() -> i256 {
    %c42 = arith.constant 42 : i256
    %c1 = arith.constant 1 : i256
    %c2 = arith.constant 2 : i256
    %c3 = arith.constant 3 : i256
    %c0 = arith.constant 0 : index
    %c1_idx = arith.constant 1 : index
    
    // Allocate in memory space (space 0)
    %temp_value = memref.alloca() {ora.region = "memory"} : memref<1xi256, 0>
    %temp_array = memref.alloca() {ora.region = "memory"} : memref<3xi256, 0>
    
    // Initialize memory variables
    memref.store %c42, %temp_value[] : memref<1xi256, 0>
    memref.store %c1, %temp_array[%c0] : memref<3xi256, 0>
    memref.store %c2, %temp_array[%c1_idx] : memref<3xi256, 0>
    memref.store %c3, %temp_array[%c2] : memref<3xi256, 0>
    
    // Memory operations
    %loaded_temp = memref.load %temp_value[] : memref<1xi256, 0>
    %doubled = arith.muli %loaded_temp, %c2 : i256
    memref.store %doubled, %temp_value[] : memref<1xi256, 0>
    memref.store %doubled, %temp_array[%c0] : memref<3xi256, 0>
    
    // Load and return
    %elem0 = memref.load %temp_array[%c0] : memref<3xi256, 0>
    %elem1 = memref.load %temp_array[%c1_idx] : memref<3xi256, 0>
    %result = arith.addi %elem0, %elem1 : i256
    return %result : i256
  } loc("memory_regions.ora":18:5)

  func.func @tstore_operations() -> i256 {
    %c1000 = arith.constant 1000 : i256
    %c2 = arith.constant 2 : i256
    %true = arith.constant true
    
    // Allocate in tstore space (space 2)
    %pending_amount = memref.alloca() {ora.region = "tstore"} : memref<1xi256, 2>
    %temp_flag = memref.alloca() {ora.region = "tstore"} : memref<1xi1, 2>
    
    // Initialize tstore variables
    memref.store %c1000, %pending_amount[] : memref<1xi256, 2>
    memref.store %true, %temp_flag[] : memref<1xi1, 2>
    
    // Conditional operation
    %flag_value = memref.load %temp_flag[] : memref<1xi1, 2>
    scf.if %flag_value {
      %current_amount = memref.load %pending_amount[] : memref<1xi256, 2>
      %halved = arith.divui %current_amount, %c2 : i256
      memref.store %halved, %pending_amount[] : memref<1xi256, 2>
    }
    
    %result = memref.load %pending_amount[] : memref<1xi256, 2>
    return %result : i256
  } loc("memory_regions.ora":32:5)

  func.func @cross_region_operations() -> i256 {
    %c50 = arith.constant 50 : i256
    
    // Load from storage (space 1)
    %balance_ref = memref.get_global @balance : memref<1xi256, 1>
    %storage_value = memref.load %balance_ref[] : memref<1xi256, 1>
    
    // Allocate in memory space (space 0) and compute
    %temp = memref.alloca() {ora.region = "memory"} : memref<1xi256, 0>
    %computed = arith.addi %storage_value, %c50 : i256
    memref.store %computed, %temp[] : memref<1xi256, 0>
    
    // Load from memory and store to storage
    %temp_value = memref.load %temp[] : memref<1xi256, 0>
    memref.store %temp_value, %balance_ref[] : memref<1xi256, 1>
    
    // Return updated storage value
    %result = memref.load %balance_ref[] : memref<1xi256, 1>
    return %result : i256
  } loc("memory_regions.ora":44:5)
}